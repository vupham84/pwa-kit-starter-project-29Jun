"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AppErrorContext = exports.AppErrorBoundaryWithoutRouter = void 0;
var _react = _interopRequireDefault(require("react"));
var _reactRouterDom = require("react-router-dom");
var _propTypes = _interopRequireDefault(require("prop-types"));
var _error = _interopRequireDefault(require("../../components/_error"));
var _errors = require("../../errors");
var _withCorrelationId = require("../with-correlation-id");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); } /*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const AppErrorContext = exports.AppErrorContext = /*#__PURE__*/_react.default.createContext();
const isProduction = process.env.NODE_ENV === 'production';

/**
 * @private
 */
class AppErrorBoundary extends _react.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: props.error
    };
    this.onGetPropsError = this.onGetPropsError.bind(this);
  }
  componentDidMount() {
    const {
      history
    } = this.props;
    if (history) {
      this.unlisten = history.listen(() => {
        // Clear error state on location change. This is used when a user
        // clicks the back button after encountering a page with an error.
        if (this.state.error) {
          this.setState({
            error: undefined
          });
        }
      });
    }
  }
  componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
    }
  }

  // React's client side error boundaries
  static getDerivedStateFromError(err) {
    // Update state so the next render will show the fallback UI
    return {
      error: {
        message: err.toString(),
        stack: err.stack
      }
    };
  }
  onGetPropsError(err) {
    if (err instanceof _errors.HTTPError) {
      this.setState({
        error: {
          message: err.message,
          status: err.status,
          stack: err.stack
        }
      });
    } else {
      this.setState({
        error: {
          message: err ? err.toString() : '',
          status: 500,
          stack: err ? err.stack : ''
        }
      });
    }
  }
  render() {
    const {
      children
    } = this.props;
    const error = this.state.error ? {
      message: this.state.error.message,
      status: this.state.error.status,
      stack: isProduction ? undefined : this.state.error.stack
    } : undefined;
    return /*#__PURE__*/_react.default.createElement(AppErrorContext.Provider, {
      value: {
        onGetPropsError: this.onGetPropsError
      }
    }, error ? /*#__PURE__*/_react.default.createElement(_error.default, _extends({}, error, {
      correlationId: this.props.correlationId
    })) : children);
  }
}
exports.AppErrorBoundaryWithoutRouter = AppErrorBoundary;
AppErrorBoundary.propTypes = {
  children: _propTypes.default.node,
  error: _propTypes.default.shape({
    message: _propTypes.default.string.isRequired,
    status: _propTypes.default.number.isRequired
  }),
  correlationId: _propTypes.default.string,
  history: _propTypes.default.object
};
var _default = exports.default = (0, _reactRouterDom.withRouter)((0, _withCorrelationId.withCorrelationId)(AppErrorBoundary));