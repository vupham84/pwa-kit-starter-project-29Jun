"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_SLAS_REFRESH_TOKEN_REGISTERED_TTL = exports.DEFAULT_SLAS_REFRESH_TOKEN_GUEST_TTL = void 0;
var _commerceSdkIsomorphic = require("commerce-sdk-isomorphic");
var _jwtDecode = require("jwt-decode");
var _storage = require("./storage");
var _utils = require("../utils");
var _constant = require("../constant");
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * Copyright (c) 2023, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/**
 * The extended field is not from api response, we manually store the auth type,
 * so we don't need to make another API call when we already have the data.
 * Plus, the getCustomer endpoint only works for registered user, it returns a 404 for a guest user,
 * and it's not easy to grab this info in user land, so we add it into the Auth object, and expose it via a hook
 */

/** A shopper could be guest or registered, so we store the refresh tokens individually. */

const isParentTrusted = (0, _utils.isOriginTrusted)((0, _utils.getParentOrigin)());

/**
 * A map of the data that this auth module stores. This maps the name of the property to
 * the storage type and the key when stored in that storage. You can also pass in a "callback"
 * function to do extra operation after a property is set.
 */
const DATA_MAP = {
  access_token: {
    storageType: 'local',
    key: 'access_token'
  },
  customer_id: {
    storageType: 'local',
    key: 'customer_id'
  },
  usid: {
    storageType: 'cookie',
    key: 'usid'
  },
  enc_user_id: {
    storageType: 'local',
    key: 'enc_user_id'
  },
  expires_in: {
    storageType: 'local',
    key: 'expires_in'
  },
  id_token: {
    storageType: 'local',
    key: 'id_token'
  },
  idp_access_token: {
    storageType: 'local',
    key: 'idp_access_token'
  },
  token_type: {
    storageType: 'local',
    key: 'token_type'
  },
  refresh_token_guest: {
    storageType: 'cookie',
    key: isParentTrusted ? 'cc-nx-g-iframe' : 'cc-nx-g',
    callback: store => {
      store.delete(isParentTrusted ? 'cc-nx-iframe' : 'cc-nx');
    }
  },
  refresh_token_registered: {
    storageType: 'cookie',
    key: isParentTrusted ? 'cc-nx-iframe' : 'cc-nx',
    callback: store => {
      store.delete(isParentTrusted ? 'cc-nx-g-iframe' : 'cc-nx-g');
    }
  },
  refresh_token_expires_in: {
    storageType: 'local',
    key: 'refresh_token_expires_in'
  },
  customer_type: {
    storageType: 'local',
    key: 'customer_type'
  },
  /*
   * For Hybrid setups, we need a mechanism to inform PWA Kit whenever customer login state changes on SFRA.
   * We do this by having SFRA store the access token in cookies. If these cookies are present, PWA
   * compares the access token from the cookie with the one in local store. If the tokens are different,
   * discard the access token in local store and replace it with the access token from the cookie.
   *
   * ECOM has a 1200 character limit on the values of cookies. The access token easily exceeds this amount
   * so it sends the access token in chunks across several cookies.
   *
   * The JWT tends to come in at around 2250 characters so there's usually
   * both a cc-at and cc-at_2.
   */
  access_token_sfra: {
    storageType: 'cookie',
    key: 'cc-at'
  },
  [_constant.DNT_COOKIE_NAME]: {
    storageType: 'cookie',
    key: _constant.DNT_COOKIE_NAME
  },
  dwsid: {
    storageType: 'cookie',
    key: _constant.DWSID_COOKIE_NAME
  },
  code_verifier: {
    storageType: 'local',
    key: 'code_verifier'
  },
  uido: {
    storageType: 'local',
    key: 'uido'
  }
};
const DEFAULT_SLAS_REFRESH_TOKEN_REGISTERED_TTL = exports.DEFAULT_SLAS_REFRESH_TOKEN_REGISTERED_TTL = 90 * 24 * 60 * 60;
const DEFAULT_SLAS_REFRESH_TOKEN_GUEST_TTL = exports.DEFAULT_SLAS_REFRESH_TOKEN_GUEST_TTL = 30 * 24 * 60 * 60;

/**
 * This class is used to handle shopper authentication.
 * It is responsible for initializing shopper session, manage access
 * and refresh tokens on server/browser environments. As well as providing
 * a mechanism to queue network calls before having a valid access token.
 *
 * @Internal
 */
class Auth {
  constructor(config) {
    // Special endpoint for injecting SLAS private client secret.
    const baseUrl = config.proxy.split(_constant.MOBIFY_PATH)[0];
    const privateClientEndpoint = `${baseUrl}${_constant.SLAS_PRIVATE_PROXY_PATH}`;
    this.client = new _commerceSdkIsomorphic.ShopperLogin({
      proxy: config.enablePWAKitPrivateClient ? privateClientEndpoint : config.proxy,
      parameters: {
        clientId: config.clientId,
        organizationId: config.organizationId,
        shortCode: config.shortCode,
        siteId: config.siteId
      },
      throwOnBadResponse: true,
      // We need to set credentials to 'same-origin' to allow cookies to be set.
      // This is required as SLAS calls return a dwsid cookie for hybrid sites.
      // The dwsid value is then passed to the SCAPI as a header maintain the server affinity.
      fetchOptions: _objectSpread({
        credentials: 'same-origin'
      }, config.fetchOptions)
    });
    this.shopperCustomersClient = new _commerceSdkIsomorphic.ShopperCustomers({
      proxy: config.proxy,
      parameters: {
        clientId: config.clientId,
        organizationId: config.organizationId,
        shortCode: config.shortCode,
        siteId: config.siteId
      },
      throwOnBadResponse: true,
      fetchOptions: config.fetchOptions
    });
    const options = {
      keySuffix: config.siteId,
      // Setting this to true on the server allows us to reuse guest auth tokens across lambda runs
      sharedContext: !(0, _utils.onClient)()
    };
    this.stores = {
      cookie: (0, _utils.onClient)() ? new _storage.CookieStorage(options) : new _storage.MemoryStorage(options),
      local: (0, _utils.onClient)() ? new _storage.LocalStorage(options) : new _storage.MemoryStorage(options),
      memory: new _storage.MemoryStorage(options)
    };
    this.redirectURI = config.redirectURI;
    this.fetchedToken = config.fetchedToken || '';
    this.logger = config.logger;
    this.defaultDnt = config.defaultDnt;
    this.refreshTokenRegisteredCookieTTL = config.refreshTokenRegisteredCookieTTL;
    this.refreshTokenGuestCookieTTL = config.refreshTokenGuestCookieTTL;

    /*
     * There are 2 ways to enable SLAS private client mode.
     * If enablePWAKitPrivateClient=true, we route SLAS calls to /mobify/slas/private
     * and set an internal placeholder as the client secret. The proxy will override the placeholder
     * with the actual client secret so any truthy value as the placeholder works here.
     *
     * If enablePWAKitPrivateClient=false and clientSecret is provided as a non-empty string,
     * private client mode is enabled but we don't route calls to /mobify/slas/private
     * This is how non-PWA Kit consumers of commerce-sdk-react can enable private client and set a secret
     *
     * If both enablePWAKitPrivateClient and clientSecret are truthy, enablePWAKitPrivateClient takes
     * priority and we ignore whatever was set for clientSecret. This prints a warning about the clientSecret
     * being ignored.
     *
     * If both enablePWAKitPrivateClient and clientSecret are falsey, we are in SLAS public client mode.
     */
    if (config.enablePWAKitPrivateClient && config.clientSecret) {
      this.logWarning(_constant.SLAS_SECRET_OVERRIDE_MSG);
    }
    this.clientSecret = config.enablePWAKitPrivateClient ?
    // PWA proxy is enabled, assume project is PWA and that the proxy will handle setting the secret
    // We can pass any truthy value here to satisfy commerce-sdk-isomorphic requirements
    _constant.SLAS_SECRET_PLACEHOLDER :
    // We think there are users of Commerce SDK React and Commerce SDK isomorphic outside of PWA
    // For these users to use a private client, they must have some way to set a client secret
    // PWA users should not need to touch this.
    config.clientSecret || '';
    this.silenceWarnings = config.silenceWarnings || false;
    this.isPrivate = !!this.clientSecret;
    const passwordlessLoginCallbackURI = config.passwordlessLoginCallbackURI;
    this.passwordlessLoginCallbackURI = passwordlessLoginCallbackURI ? (0, _utils.isAbsoluteUrl)(passwordlessLoginCallbackURI) ? passwordlessLoginCallbackURI : `${baseUrl}${passwordlessLoginCallbackURI}` : '';
  }
  get(name) {
    const {
      key,
      storageType
    } = DATA_MAP[name];
    const storage = this.stores[storageType];
    return storage.get(key);
  }
  set(name, value, options) {
    var _DATA_MAP$name$callba, _DATA_MAP$name;
    const {
      key,
      storageType
    } = DATA_MAP[name];
    const storage = this.stores[storageType];
    storage.set(key, value, options);
    (_DATA_MAP$name$callba = (_DATA_MAP$name = DATA_MAP[name]).callback) === null || _DATA_MAP$name$callba === void 0 ? void 0 : _DATA_MAP$name$callba.call(_DATA_MAP$name, storage);
  }
  delete(name) {
    const {
      key,
      storageType
    } = DATA_MAP[name];
    const storage = this.stores[storageType];
    storage.delete(key);
  }

  /**
   * Return the value of the DNT cookie or undefined if it is not set.
   * The DNT cookie being undefined means that there is a necessity to
   * get the user's input for consent tracking, but not that there is no
   * DNT value to apply to analytics layers. DNT value will default to
   * a certain value and this is reflected by effectiveDnt.
   *
   * If the cookie value is invalid, then it will be deleted in this function.
   *
   * If includeDefaults is true, then even if the cookie is not defined,
   * defaultDnt will be returned, if it exists. If defaultDnt is not defined, then
   * the SDK Default will return (false)
   */
  getDnt(options) {
    const dntCookieVal = this.get(_constant.DNT_COOKIE_NAME);
    let dntCookieStatus = undefined;
    const accessToken = this.getAccessToken();
    let isInSync = true;
    if (accessToken) {
      const {
        dnt
      } = this.parseSlasJWT(accessToken);
      isInSync = dnt === dntCookieVal;
    }
    if (dntCookieVal !== '1' && dntCookieVal !== '0' || !isInSync) {
      this.delete(_constant.DNT_COOKIE_NAME);
    } else {
      dntCookieStatus = Boolean(Number(dntCookieVal));
    }
    if (options !== null && options !== void 0 && options.includeDefaults) {
      const defaultDnt = this.defaultDnt;
      let effectiveDnt;
      const dntCookie = dntCookieVal === '1' ? true : dntCookieVal === '0' ? false : undefined;
      if (dntCookie !== undefined) {
        effectiveDnt = dntCookie;
      } else {
        // If the cookie is not set, read the defaultDnt preference.
        // If defaultDnt doesn't exist, default to false, following SLAS default for dnt
        effectiveDnt = defaultDnt !== undefined ? defaultDnt : false;
      }
      return effectiveDnt;
    }
    return dntCookieStatus;
  }
  setDnt(preference) {
    var _this = this;
    return _asyncToGenerator(function* () {
      let dntCookieVal = String(Number(preference));
      // Use defaultDNT if defined. If not, use SLAS default DNT
      if (preference === null) {
        dntCookieVal = _this.defaultDnt ? String(Number(_this.defaultDnt)) : '0';
      }
      // Set the cookie once to include dnt in the access token and then again to set the expiry time
      _this.set(_constant.DNT_COOKIE_NAME, dntCookieVal, _objectSpread(_objectSpread({}, (0, _utils.getDefaultCookieAttributes)()), {}, {
        secure: true
      }));
      const accessToken = _this.getAccessToken();
      if (accessToken !== '') {
        const {
          dnt
        } = _this.parseSlasJWT(accessToken);
        if (dnt !== dntCookieVal) {
          yield _this.refreshAccessToken();
        }
      } else {
        yield _this.refreshAccessToken();
      }
      if (preference !== null) {
        const SECONDS_IN_DAY = 86400;
        _this.set(_constant.DNT_COOKIE_NAME, dntCookieVal, _objectSpread(_objectSpread({}, (0, _utils.getDefaultCookieAttributes)()), {}, {
          secure: true,
          expires: Number(_this.get('refresh_token_expires_in')) / SECONDS_IN_DAY
        }));
      }
    })();
  }
  clearStorage() {
    // Type assertion because Object.keys is silly and limited :(
    const keys = Object.keys(DATA_MAP);
    keys.forEach(keyName => {
      const {
        key,
        storageType
      } = DATA_MAP[keyName];
      const store = this.stores[storageType];
      store.delete(key);
    });
  }

  /**
   * Every method in this class that returns a `TokenResponse` constructs it via this getter.
   */
  get data() {
    return {
      access_token: this.get('access_token'),
      customer_id: this.get('customer_id'),
      enc_user_id: this.get('enc_user_id'),
      expires_in: parseInt(this.get('expires_in')),
      id_token: this.get('id_token'),
      idp_access_token: this.get('idp_access_token'),
      refresh_token: this.get('refresh_token_registered') || this.get('refresh_token_guest'),
      token_type: this.get('token_type'),
      usid: this.get('usid'),
      customer_type: this.get('customer_type'),
      refresh_token_expires_in: this.get('refresh_token_expires_in')
    };
  }

  /**
   * Used to validate JWT token expiration.
   */
  isTokenExpired(token) {
    const {
      exp,
      iat
    } = (0, _jwtDecode.jwtDecode)(token.replace('Bearer ', ''));
    const validTimeSeconds = exp - iat - 60;
    const tokenAgeSeconds = Date.now() / 1000 - iat;
    return validTimeSeconds <= tokenAgeSeconds;
  }

  /**
   * Returns the SLAS access token or an empty string if the access token
   * is not found in local store or if SFRA wants PWA to trigger refresh token login.
   *
   * On PWA-only sites, this returns the access token from local storage.
   * On Hybrid sites, this checks whether SFRA has sent an auth token via cookies.
   * Returns an access token from SFRA if it exist.
   * If not, the access token from local store is returned.
   *
   * This is only used within this Auth module since other modules consider the access
   * token from this.get('access_token') to be the source of truth.
   *
   * @returns {string} access token
   */
  getAccessToken() {
    let accessToken = this.get('access_token');
    const sfraAuthToken = this.get('access_token_sfra');
    if (sfraAuthToken) {
      /*
       * If SFRA sends 'refresh', we return an empty token here so PWA can trigger a login refresh
       * This key is used when logout is triggered in SFRA but the redirect after logout
       * sends the user to PWA.
       */
      if (sfraAuthToken === 'refresh') {
        this.set('access_token', '');
        this.clearSFRAAuthToken();
        return '';
      }
      const {
        isGuest,
        customerId,
        usid
      } = this.parseSlasJWT(sfraAuthToken);
      this.set('access_token', sfraAuthToken);
      this.set('customer_id', customerId);
      this.set('usid', usid);
      this.set('customer_type', isGuest ? 'guest' : 'registered');
      accessToken = sfraAuthToken;
      // SFRA -> PWA access token cookie handoff is succesful so we clear the SFRA made cookies.
      // We don't want these cookies to persist and continue overriding what is in local store.
      this.clearSFRAAuthToken();
    }
    return accessToken;
  }

  /**
   * For Hybrid storefronts ONLY!!!
   * This method clears out SLAS access token generated in Plugin SLAS and passed in via "cc-at" cookie.
   *
   * In a hybrid setup, whenever any SLAS flow executes in Plugin SLAS and an access token is generated,
   * the access token is sent over to PWA Kit using cc-at cookie.
   *
   * PWA Kit will check to see if cc-at cookie exists, if it does, the access token value in localStorage is updated
   * with value from the cc-at cookie and is then used for all SCAPI requests made from PWA Kit. The cc-at cookie is then cleared.
   */
  clearSFRAAuthToken() {
    const {
      key,
      storageType
    } = DATA_MAP['access_token_sfra'];
    const store = this.stores[storageType];
    store.delete(key);
  }

  /**
   * For Hybrid storefronts ONLY!!!
   * This method clears the dwsid cookie from the browser.
   * In a hybrid setup, dwsid points to an ECOM session and is passed between PWA Kit and SFRA/SG sites via "dwsid" cookie.
   *
   * Whenever a registered shopper logs in on PWA Kit, we must clear the dwsid cookie if one exists. When shopper navigates
   * to SFRA as a logged-in shopper, ECOM notices a missing DWSID, generates a new DWSID and triggers the onSession hook which uses
   * registered shopper refresh-token and restores session and basket on SFRA.
   */
  clearECOMSession() {
    const {
      key,
      storageType
    } = DATA_MAP[_constant.DWSID_COOKIE_NAME];
    const store = this.stores[storageType];
    store.delete(key);
  }

  /**
   * Converts a duration in seconds to a Date object.
   * This function takes a number representing seconds and returns a Date object
   * for the current time plus the given duration.
   *
   * @param {number} seconds - The number of seconds to add to the current time.
   * @returns {Date} A Date object for the expiration time.
   */
  convertSecondsToDate(seconds) {
    if (typeof seconds !== 'number') {
      throw new Error('The refresh_token_expires_in seconds parameter must be a number.');
    }
    return new Date(Date.now() + seconds * 1000);
  }

  /**
   * Retrieves our refresh token cookie ttl value
   */
  getRefreshTokenCookieTTLValue(overrideValue, responseValue, defaultValue) {
    // Check if overrideValue is valid
    // if not, log warning and fall back to responseValue or defaultValue
    const isOverrideValid = typeof overrideValue === 'number' && overrideValue > 0 && overrideValue <= defaultValue;
    if (!isOverrideValid && overrideValue !== undefined) {
      this.logWarning(_constant.SLAS_REFRESH_TOKEN_COOKIE_TTL_OVERRIDE_MSG);
    }

    // Return the first valid value: overrideValue (if valid), responseValue, or defaultValue
    return isOverrideValid ? overrideValue : responseValue || defaultValue;
  }

  /**
   * This method stores the TokenResponse object retrieved from SLAS, and
   * store the data in storage.
   */
  handleTokenResponse(res, isGuest) {
    this.set('access_token', res.access_token);
    this.set('customer_id', res.customer_id);
    this.set('enc_user_id', res.enc_user_id);
    this.set('expires_in', `${res.expires_in}`);
    this.set('id_token', res.id_token);
    this.set('idp_access_token', res.idp_access_token);
    this.set('token_type', res.token_type);
    this.set('usid', res.usid);
    this.set('customer_type', isGuest ? 'guest' : 'registered');
    const refreshTokenKey = isGuest ? 'refresh_token_guest' : 'refresh_token_registered';
    const overrideValue = isGuest ? this.refreshTokenGuestCookieTTL : this.refreshTokenRegisteredCookieTTL;
    const responseValue = res.refresh_token_expires_in;
    const defaultValue = isGuest ? DEFAULT_SLAS_REFRESH_TOKEN_GUEST_TTL : DEFAULT_SLAS_REFRESH_TOKEN_REGISTERED_TTL;
    const refreshTokenTTLValue = this.getRefreshTokenCookieTTLValue(overrideValue, responseValue, defaultValue);
    if (res.access_token) {
      const {
        uido
      } = this.parseSlasJWT(res.access_token);
      this.set('uido', uido);
    }
    const expiresDate = this.convertSecondsToDate(refreshTokenTTLValue);
    this.set('refresh_token_expires_in', refreshTokenTTLValue.toString());
    this.set(refreshTokenKey, res.refresh_token, {
      expires: expiresDate
    });
  }
  refreshAccessToken() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const dntPref = _this2.getDnt({
        includeDefaults: true
      });
      const refreshTokenRegistered = _this2.get('refresh_token_registered');
      const refreshTokenGuest = _this2.get('refresh_token_guest');
      const refreshToken = refreshTokenRegistered || refreshTokenGuest;
      if (refreshToken) {
        try {
          return yield _this2.queueRequest(() => _commerceSdkIsomorphic.helpers.refreshAccessToken(_this2.client, {
            refreshToken,
            dnt: dntPref
          }, {
            clientSecret: _this2.clientSecret
          }), !!refreshTokenGuest);
        } catch (error) {
          // If the refresh token is invalid, we need to re-login the user
          if (error instanceof Error && 'response' in error) {
            // commerce-sdk-isomorphic throws a `ResponseError`, but doesn't export the class.
            // We can't use `instanceof`, so instead we just check for the `response` property
            // and assume it is a fetch Response.
            const json = yield error['response'].json();
            if (json.message === 'invalid refresh_token') {
              // clean up storage and restart the login flow
              _this2.clearStorage();
            }
          }
        }
      }

      // refresh flow for TAOB
      const accessToken = _this2.getAccessToken();
      if (accessToken && _this2.isTokenExpired(accessToken)) {
        try {
          const {
            isGuest,
            usid,
            loginId,
            isAgent
          } = _this2.parseSlasJWT(accessToken);
          if (isAgent) {
            return yield _this2.queueRequest(() => _this2.refreshTrustedAgent(loginId, usid), isGuest);
          }
        } catch (e) {
          /* catch invalid jwt */
        }
      }

      // if a TAOB left a usid and it tries to
      // use it, we will be stuck in a fail loop
      let token;
      try {
        token = yield _this2.loginGuestUser();
      } catch (e) {
        _this2.clearStorage();
        token = yield _this2.loginGuestUser();
      }
      return token;
    })();
  }

  /**
   * This method queues the requests and handles the SLAS token response.
   *
   * It returns the queue.
   *
   * @Internal
   */
  queueRequest(fn, isGuest) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      const queue = _this3.pendingToken ?? Promise.resolve();
      _this3.pendingToken = queue.then( /*#__PURE__*/_asyncToGenerator(function* () {
        const token = yield fn();
        _this3.handleTokenResponse(token, isGuest);
        // Q: Why don't we just return token? Why re-construct the same object again?
        // A: because a user could open multiple tabs and the data in memory could be out-dated
        // We must always grab the data from the storage (cookie/localstorage) directly
        return _this3.data;
      })).finally(() => {
        _this3.pendingToken = undefined;
      });
      return yield _this3.pendingToken;
    })();
  }
  logWarning = msg => {
    if (!this.silenceWarnings) {
      this.logger.warn(msg);
    }
  };

  /**
   * This method extracts the status and message from a ResponseError that is returned
   * by commerce-sdk-isomorphic.
   *
   * commerce-sdk-isomorphic throws a `ResponseError`, but doesn't export the class.
   * We can't use `instanceof`, so instead we just check for the `response` property
   * and assume it is a `ResponseError` if a response is present
   *
   * Once commerce-sdk-isomorphic exports `ResponseError` we can revisit if this method is
   * still required.
   *
   * @returns {status_code, responseMessage} contained within the ResponseError
   * @throws error if the error is not a ResponseError
   * @Internal
   */
  extractResponseError = (() => function () {
    var _ref2 = _asyncToGenerator(function* (error) {
      // the regular error.message will return only the generic status code message
      // ie. 'Bad Request' for 400. We need to drill specifically into the ResponseError
      // to get a more descriptive error message from SLAS
      if ('response' in error) {
        const json = yield error['response'].json();
        const status_code = json.status_code;
        const responseMessage = json.message;
        return {
          status_code,
          responseMessage
        };
      }
      throw error;
    });
    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }())();

  /**
   * The ready function returns a promise that resolves with valid ShopperLogin
   * token response.
   *
   * When this method is called for the very first time, it initializes the session
   * by following the public client auth flow to get access token for the user.
   * The flow:
   * 1. If we have valid access token - use it
   * 2. If we have valid refresh token - refresh token flow
   * 3. If we have valid TAOB access token - refresh TAOB token flow
   * 4. PKCE flow
   */
  ready() {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      if (_this4.fetchedToken && _this4.fetchedToken !== '') {
        const {
          isGuest,
          customerId,
          usid
        } = _this4.parseSlasJWT(_this4.fetchedToken);
        _this4.set('access_token', _this4.fetchedToken);
        _this4.set('customer_id', customerId);
        _this4.set('usid', usid);
        _this4.set('customer_type', isGuest ? 'guest' : 'registered');
        return _this4.data;
      }
      if (_this4.pendingToken) {
        return yield _this4.pendingToken;
      }
      const accessToken = _this4.getAccessToken();
      if (accessToken && !_this4.isTokenExpired(accessToken)) {
        return _this4.data;
      }
      return yield _this4.refreshAccessToken();
    })();
  }

  /**
   * Creates a function that only executes after a session is initialized.
   * @param fn Function that needs to wait until the session is initialized.
   * @returns Wrapped function
   */
  whenReady(fn) {
    var _this5 = this;
    return /*#__PURE__*/_asyncToGenerator(function* (...args) {
      yield _this5.ready();
      return yield fn(...args);
    });
  }

  /**
   * A wrapper method for commerce-sdk-isomorphic helper: loginGuestUser.
   *
   */
  loginGuestUser() {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      if (_this6.clientSecret && (0, _utils.onClient)() && _this6.clientSecret !== _constant.SLAS_SECRET_PLACEHOLDER) {
        _this6.logWarning(_constant.SLAS_SECRET_WARNING_MSG);
      }
      const usid = _this6.get('usid');
      const dntPref = _this6.getDnt({
        includeDefaults: true
      });
      const isGuest = true;
      const guestPrivateArgs = [_this6.client, _objectSpread({
        dnt: dntPref
      }, usid && {
        usid
      }), {
        clientSecret: _this6.clientSecret
      }];
      const guestPublicArgs = [_this6.client, _objectSpread({
        redirectURI: _this6.redirectURI,
        dnt: dntPref
      }, usid && {
        usid
      })];
      const callback = _this6.clientSecret ? () => _commerceSdkIsomorphic.helpers.loginGuestUserPrivate(...guestPrivateArgs) : () => _commerceSdkIsomorphic.helpers.loginGuestUser(...guestPublicArgs);
      try {
        return yield _this6.queueRequest(callback, isGuest);
      } catch (error) {
        // We catch the error here to do logging but we still need to
        // throw an error to stop the login flow from continuing.
        const {
          status_code,
          responseMessage
        } = yield _this6.extractResponseError(error);
        _this6.logger.error(`${status_code} ${responseMessage}`);
        throw new Error(`New guest user could not be logged in. ${status_code} ${responseMessage}`);
      }
    })();
  }

  /**
   * This is a wrapper method for ShopperCustomer API registerCustomer endpoint.
   *
   */
  register(body) {
    var _this7 = this;
    return _asyncToGenerator(function* () {
      const {
        customer: {
          login
        },
        password
      } = body;

      // login is optional field from isomorphic library
      // type CustomerRegistration
      // here we had to guard it to avoid ts error
      if (!login) {
        throw new Error('Customer registration is missing login field.');
      }
      const res = yield _this7.shopperCustomersClient.registerCustomer({
        headers: {
          authorization: `Bearer ${_this7.get('access_token')}`
        },
        body
      });
      yield _this7.loginRegisteredUserB2C({
        username: login,
        password
      });
      return res;
    })();
  }

  /**
   * A wrapper method for commerce-sdk-isomorphic helper: loginRegisteredUserB2C.
   *
   */
  loginRegisteredUserB2C(credentials) {
    var _this8 = this;
    return _asyncToGenerator(function* () {
      if (_this8.clientSecret && (0, _utils.onClient)() && _this8.clientSecret !== _constant.SLAS_SECRET_PLACEHOLDER) {
        _this8.logWarning(_constant.SLAS_SECRET_WARNING_MSG);
      }
      const redirectURI = _this8.redirectURI;
      const usid = _this8.get('usid');
      const dntPref = _this8.getDnt({
        includeDefaults: true
      });
      const isGuest = false;
      const token = yield _commerceSdkIsomorphic.helpers.loginRegisteredUserB2C(_this8.client, _objectSpread(_objectSpread({}, credentials), {}, {
        clientSecret: _this8.clientSecret
      }), _objectSpread({
        redirectURI,
        dnt: dntPref
      }, usid && {
        usid
      }));
      _this8.handleTokenResponse(token, isGuest);
      if ((0, _utils.onClient)()) {
        void _this8.clearECOMSession();
      }
      return token;
    })();
  }

  /**
   * Trusted agent authorization
   *
   * @warning This method is not supported on the server, it is a client-only method.
   */
  authorizeTrustedAgent(credentials) {
    var _this9 = this;
    return _asyncToGenerator(function* () {
      const slasClient = _this9.client;
      const codeVerifier = _commerceSdkIsomorphic.helpers.createCodeVerifier();
      const codeChallenge = yield _commerceSdkIsomorphic.helpers.generateCodeChallenge(codeVerifier);
      const organizationId = slasClient.clientConfig.parameters.organizationId;
      const clientId = slasClient.clientConfig.parameters.clientId;
      const siteId = slasClient.clientConfig.parameters.siteId;
      const loginId = credentials.loginId || 'guest';
      const isGuest = loginId === 'guest';
      const idpOrigin = isGuest ? 'slas' : 'ecom';
      const url = `${slasClient.clientConfig.proxy || ''}/shopper/auth/v1/organizations/${organizationId}/oauth2/trusted-agent/authorize?${[...[`client_id=${clientId}`, `channel_id=${siteId}`, `login_id=${loginId}`, `redirect_uri=${_this9.redirectURI}`, `idp_origin=${idpOrigin}`, `response_type=code`], ...(!_this9.clientSecret ? [`code_challenge=${codeChallenge}`] : [])].join('&')}`;
      return {
        url,
        codeVerifier
      };
    })();
  }

  /**
   * Trusted agent login
   *
   * @warning This method is not supported on the server, it is a client-only method.
   */
  loginTrustedAgent(credentials) {
    var _this10 = this;
    return _asyncToGenerator(function* () {
      const slasClient = _this10.client;
      const loginId = credentials.loginId || 'guest';
      const isGuest = loginId === 'guest';
      const idpOrigin = isGuest ? 'slas' : 'ecom';
      const optionsToken = {
        headers: {
          Authorization: `Bearer ${credentials.code}`
        },
        body: _objectSpread(_objectSpread(_objectSpread({
          channel_id: slasClient.clientConfig.parameters.siteId,
          grant_type: 'client_credentials',
          redirect_uri: _this10.redirectURI,
          login_id: loginId,
          idp_origin: idpOrigin,
          dnt: 'true'
        }, !_this10.clientSecret && {
          client_id: slasClient.clientConfig.parameters.clientId,
          code_verifier: credentials.codeVerifier
        }), credentials.state && {
          state: credentials.state
        }), credentials.usid && {
          usid: credentials.usid
        })
      };

      // using slas private client
      if (credentials.clientSecret) {
        optionsToken.headers._sfdc_client_auth = `Basic ${_commerceSdkIsomorphic.helpers.stringToBase64(`${slasClient.clientConfig.parameters.clientId}:${credentials.clientSecret}`)}`;
      }
      const token = yield slasClient.getTrustedAgentAccessToken(optionsToken);
      _this10.handleTokenResponse(token, isGuest);
      return token;
    })();
  }
  /**
   * Trusted agent refresh handler
   *
   * @warning This method is not supported on the server, it is a client-only method.
   */
  registerTrustedAgentRefreshHandler(refreshTrustedAgentHandler) {
    this.refreshTrustedAgentHandler = refreshTrustedAgentHandler;
  }
  refreshTrustedAgent(loginId, usid) {
    var _this11 = this;
    return _asyncToGenerator(function* () {
      if (_this11.refreshTrustedAgentHandler) {
        return yield _this11.refreshTrustedAgentHandler(loginId, usid, true);
      }
      _this11.clearStorage();
      return yield _this11.loginGuestUser();
    })();
  }

  /**
   * A wrapper method for commerce-sdk-isomorphic helper: logout.
   *
   */
  logout() {
    var _this12 = this;
    return _asyncToGenerator(function* () {
      if (_this12.get('customer_type') === 'registered') {
        // Not awaiting on purpose because there isn't much we can do if this fails.
        void _commerceSdkIsomorphic.helpers.logout(_this12.client, {
          accessToken: _this12.get('access_token'),
          refreshToken: _this12.get('refresh_token_registered')
        });
      }
      _this12.clearStorage();
      return yield _this12.ready();
    })();
  }

  /**
   * Handle updating customer password and re-log in after the access token is invalidated.
   *
   */
  updateCustomerPassword(body) {
    var _this13 = this;
    return _asyncToGenerator(function* () {
      const {
        customer: {
          customerId,
          login
        },
        password,
        currentPassword,
        shouldReloginCurrentSession
      } = body;

      // login and customerId are optional fields on the Customer type
      // here we had to guard it to avoid ts error
      if (!login || !customerId) {
        throw new Error('Customer is missing required fields.');
      }
      const res = yield _this13.shopperCustomersClient.updateCustomerPassword({
        headers: {
          authorization: `Bearer ${_this13.get('access_token')}`
        },
        parameters: {
          customerId
        },
        body: {
          password: password,
          currentPassword: currentPassword
        }
      });
      if (shouldReloginCurrentSession) {
        yield _this13.loginRegisteredUserB2C({
          username: login,
          password
        });
      }
      return res;
    })();
  }

  /**
   * A wrapper method for commerce-sdk-isomorphic helper: authorizeIDP.
   *
   */
  authorizeIDP(parameters) {
    var _this14 = this;
    return _asyncToGenerator(function* () {
      const redirectURI = parameters.redirectURI || _this14.redirectURI;
      const usid = _this14.get('usid');
      const {
        url,
        codeVerifier
      } = yield _commerceSdkIsomorphic.helpers.authorizeIDP(_this14.client, _objectSpread({
        redirectURI,
        hint: parameters.hint
      }, usid && {
        usid
      }), _this14.isPrivate);
      if ((0, _utils.onClient)()) {
        window.location.assign(url);
      } else {
        console.warn('Something went wrong, this client side method is invoked on the server.');
      }
      _this14.set('code_verifier', codeVerifier);
    })();
  }

  /**
   * A wrapper method for commerce-sdk-isomorphic helper: loginIDPUser.
   *
   */
  loginIDPUser(parameters) {
    var _this15 = this;
    return _asyncToGenerator(function* () {
      const codeVerifier = _this15.get('code_verifier');
      const code = parameters.code;
      const usid = parameters.usid || _this15.get('usid');
      const redirectURI = parameters.redirectURI || _this15.redirectURI;
      const dntPref = _this15.getDnt({
        includeDefaults: true
      });
      const token = yield _commerceSdkIsomorphic.helpers.loginIDPUser(_this15.client, {
        codeVerifier,
        clientSecret: _this15.clientSecret
      }, _objectSpread({
        redirectURI,
        code,
        dnt: dntPref
      }, usid && {
        usid
      }));
      const isGuest = false;
      _this15.handleTokenResponse(token, isGuest);
      // Delete the code verifier once the user has logged in
      _this15.delete('code_verifier');
      if ((0, _utils.onClient)()) {
        void _this15.clearECOMSession();
      }
      return token;
    })();
  }

  /**
   * A wrapper method for commerce-sdk-isomorphic helper: authorizePasswordless.
   */
  authorizePasswordless(parameters) {
    var _this16 = this;
    return _asyncToGenerator(function* () {
      const userid = parameters.userid;
      const callbackURI = parameters.callbackURI || _this16.passwordlessLoginCallbackURI;
      const usid = _this16.get('usid');
      const mode = callbackURI ? 'callback' : 'sms';
      const res = yield _commerceSdkIsomorphic.helpers.authorizePasswordless(_this16.client, {
        clientSecret: _this16.clientSecret
      }, _objectSpread(_objectSpread(_objectSpread({}, callbackURI && {
        callbackURI: callbackURI
      }), usid && {
        usid
      }), {}, {
        userid,
        mode
      }));
      if (res && res.status !== 200) {
        const errorData = yield res.json();
        throw new Error(`${res.status} ${String(errorData.message)}`);
      }
      return res;
    })();
  }

  /**
   * A wrapper method for commerce-sdk-isomorphic helper: getPasswordLessAccessToken.
   */
  getPasswordLessAccessToken(parameters) {
    var _this17 = this;
    return _asyncToGenerator(function* () {
      const pwdlessLoginToken = parameters.pwdlessLoginToken;
      const dntPref = _this17.getDnt({
        includeDefaults: true
      });
      const token = yield _commerceSdkIsomorphic.helpers.getPasswordLessAccessToken(_this17.client, {
        clientSecret: _this17.clientSecret
      }, {
        pwdlessLoginToken,
        dnt: dntPref !== undefined ? String(dntPref) : undefined
      });
      const isGuest = false;
      _this17.handleTokenResponse(token, isGuest);
      if ((0, _utils.onClient)()) {
        void _this17.clearECOMSession();
      }
      return token;
    })();
  }

  /**
   * A wrapper method for the SLAS endpoint: getPasswordResetToken.
   *
   */
  getPasswordResetToken(parameters) {
    var _this18 = this;
    return _asyncToGenerator(function* () {
      const slasClient = _this18.client;
      const callbackURI = parameters.callback_uri;
      const options = {
        headers: {
          Authorization: ''
        },
        body: {
          user_id: parameters.user_id,
          mode: 'callback',
          channel_id: slasClient.clientConfig.parameters.siteId,
          client_id: slasClient.clientConfig.parameters.clientId,
          callback_uri: callbackURI,
          hint: 'cross_device'
        }
      };

      // Only set authorization header if using private client
      if (_this18.clientSecret) {
        options.headers.Authorization = `Basic ${(0, _utils.stringToBase64)(`${slasClient.clientConfig.parameters.clientId}:${_this18.clientSecret}`)}`;
      }
      const res = yield slasClient.getPasswordResetToken(options);
      return res;
    })();
  }

  /**
   * A wrapper method for the SLAS endpoint: resetPassword.
   *
   */
  resetPassword(parameters) {
    var _this19 = this;
    return _asyncToGenerator(function* () {
      const slasClient = _this19.client;
      const options = {
        headers: {
          Authorization: ''
        },
        body: {
          pwd_action_token: parameters.pwd_action_token,
          channel_id: slasClient.clientConfig.parameters.siteId,
          client_id: slasClient.clientConfig.parameters.clientId,
          new_password: parameters.new_password,
          user_id: parameters.user_id
        }
      };

      // Only set authorization header if using private client
      if (_this19.clientSecret) {
        options.headers.Authorization = `Basic ${(0, _utils.stringToBase64)(`${slasClient.clientConfig.parameters.clientId}:${_this19.clientSecret}`)}`;
      }
      // TODO: no code verifier needed with the fix blair has made, delete this when the fix has been merged to production
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      const res = yield _this19.client.resetPassword(options);
      return res;
    })();
  }

  /**
   * Decode SLAS JWT and extract information such as customer id, usid, etc.
   *
   */
  parseSlasJWT(jwt) {
    var _isbParts, _isbParts2;
    const payload = (0, _jwtDecode.jwtDecode)(jwt);
    const {
      sub,
      isb,
      dnt
    } = payload;
    if (!sub || !isb) {
      throw new Error('Unable to parse access token payload: missing sub and isb.');
    }

    // ISB format
    // 'uido:ecom::upn:Guest||xxxEmailxxx::uidn:FirstName LastName::gcid:xxxGuestCustomerIdxxx::rcid:xxxRegisteredCustomerIdxxx::chid:xxxSiteIdxxx',
    const isbParts = isb.split('::');
    const uido = isbParts[0].split('uido:')[1];
    const isGuest = isbParts[1] === 'upn:Guest';
    const customerId = isGuest ? isbParts[3].replace('gcid:', '') : isbParts[4].replace('rcid:', '');
    const loginId = isGuest ? 'guest' : isbParts[1].replace('upn:', '');
    const isAgent = !!(isbParts !== null && isbParts !== void 0 && (_isbParts = isbParts[isGuest ? 5 : 6]) !== null && _isbParts !== void 0 && _isbParts.startsWith('agent:'));
    const agentId = isAgent ? isbParts === null || isbParts === void 0 ? void 0 : (_isbParts2 = isbParts[isGuest ? 5 : 6]) === null || _isbParts2 === void 0 ? void 0 : _isbParts2.replace('agent:', '') : null;

    // SUB format
    // cc-slas::zzrf_001::scid:c9c45bfd-0ed3-4aa2-xxxx-40f88962b836::usid:b4865233-de92-4039-xxxx-aa2dfc8c1ea5
    const usid = sub.split('::')[3].replace('usid:', '');
    return {
      isGuest,
      customerId,
      usid,
      dnt,
      loginId,
      isAgent,
      agentId,
      uido
    };
  }
}
var _default = exports.default = Auth;