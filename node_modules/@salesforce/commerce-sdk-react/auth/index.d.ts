import { helpers, ShopperLoginTypes, ShopperCustomersTypes } from 'commerce-sdk-isomorphic';
import { ApiClientConfigParams, Prettify, RemoveStringIndex } from '../hooks/types';
import { CustomerType } from '../hooks/useCustomerType';
import { DNT_COOKIE_NAME, DWSID_COOKIE_NAME } from '../constant';
import { Logger } from '../types';
type TokenResponse = ShopperLoginTypes.TokenResponse;
type Helpers = typeof helpers;
interface AuthConfig extends ApiClientConfigParams {
    redirectURI: string;
    proxy: string;
    fetchOptions?: ShopperLoginTypes.FetchOptions;
    fetchedToken?: string;
    enablePWAKitPrivateClient?: boolean;
    clientSecret?: string;
    silenceWarnings?: boolean;
    logger: Logger;
    defaultDnt?: boolean;
    passwordlessLoginCallbackURI?: string;
    refreshTokenRegisteredCookieTTL?: number;
    refreshTokenGuestCookieTTL?: number;
}
type AuthorizeIDPParams = Parameters<Helpers['authorizeIDP']>[1];
type LoginIDPUserParams = Parameters<Helpers['loginIDPUser']>[2];
type AuthorizePasswordlessParams = Parameters<Helpers['authorizePasswordless']>[2];
type LoginPasswordlessParams = Parameters<Helpers['getPasswordLessAccessToken']>[2];
type LoginRegisteredUserB2CCredentials = Parameters<Helpers['loginRegisteredUserB2C']>[1];
/**
 * The extended field is not from api response, we manually store the auth type,
 * so we don't need to make another API call when we already have the data.
 * Plus, the getCustomer endpoint only works for registered user, it returns a 404 for a guest user,
 * and it's not easy to grab this info in user land, so we add it into the Auth object, and expose it via a hook
 */
export type AuthData = Prettify<RemoveStringIndex<TokenResponse> & {
    customer_type: CustomerType;
    idp_access_token: string;
}>;
/** A shopper could be guest or registered, so we store the refresh tokens individually. */
type AuthDataKeys = Exclude<keyof AuthData, 'refresh_token'> | 'refresh_token_guest' | 'refresh_token_registered' | 'access_token_sfra' | typeof DNT_COOKIE_NAME | typeof DWSID_COOKIE_NAME | 'code_verifier' | 'uido';
type DntOptions = {
    includeDefaults: boolean;
};
export declare const DEFAULT_SLAS_REFRESH_TOKEN_REGISTERED_TTL: number;
export declare const DEFAULT_SLAS_REFRESH_TOKEN_GUEST_TTL: number;
/**
 * This class is used to handle shopper authentication.
 * It is responsible for initializing shopper session, manage access
 * and refresh tokens on server/browser environments. As well as providing
 * a mechanism to queue network calls before having a valid access token.
 *
 * @Internal
 */
declare class Auth {
    private client;
    private shopperCustomersClient;
    private redirectURI;
    private pendingToken;
    private stores;
    private fetchedToken;
    private clientSecret;
    private silenceWarnings;
    private logger;
    private defaultDnt;
    private isPrivate;
    private passwordlessLoginCallbackURI;
    private refreshTokenRegisteredCookieTTL;
    private refreshTokenGuestCookieTTL;
    private refreshTrustedAgentHandler;
    constructor(config: AuthConfig);
    get(name: AuthDataKeys): string;
    private set;
    private delete;
    /**
     * Return the value of the DNT cookie or undefined if it is not set.
     * The DNT cookie being undefined means that there is a necessity to
     * get the user's input for consent tracking, but not that there is no
     * DNT value to apply to analytics layers. DNT value will default to
     * a certain value and this is reflected by effectiveDnt.
     *
     * If the cookie value is invalid, then it will be deleted in this function.
     *
     * If includeDefaults is true, then even if the cookie is not defined,
     * defaultDnt will be returned, if it exists. If defaultDnt is not defined, then
     * the SDK Default will return (false)
     */
    getDnt(options?: DntOptions): boolean | undefined;
    setDnt(preference: boolean | null): Promise<void>;
    private clearStorage;
    /**
     * Every method in this class that returns a `TokenResponse` constructs it via this getter.
     */
    private get data();
    /**
     * Used to validate JWT token expiration.
     */
    private isTokenExpired;
    /**
     * Returns the SLAS access token or an empty string if the access token
     * is not found in local store or if SFRA wants PWA to trigger refresh token login.
     *
     * On PWA-only sites, this returns the access token from local storage.
     * On Hybrid sites, this checks whether SFRA has sent an auth token via cookies.
     * Returns an access token from SFRA if it exist.
     * If not, the access token from local store is returned.
     *
     * This is only used within this Auth module since other modules consider the access
     * token from this.get('access_token') to be the source of truth.
     *
     * @returns {string} access token
     */
    private getAccessToken;
    /**
     * For Hybrid storefronts ONLY!!!
     * This method clears out SLAS access token generated in Plugin SLAS and passed in via "cc-at" cookie.
     *
     * In a hybrid setup, whenever any SLAS flow executes in Plugin SLAS and an access token is generated,
     * the access token is sent over to PWA Kit using cc-at cookie.
     *
     * PWA Kit will check to see if cc-at cookie exists, if it does, the access token value in localStorage is updated
     * with value from the cc-at cookie and is then used for all SCAPI requests made from PWA Kit. The cc-at cookie is then cleared.
     */
    private clearSFRAAuthToken;
    /**
     * For Hybrid storefronts ONLY!!!
     * This method clears the dwsid cookie from the browser.
     * In a hybrid setup, dwsid points to an ECOM session and is passed between PWA Kit and SFRA/SG sites via "dwsid" cookie.
     *
     * Whenever a registered shopper logs in on PWA Kit, we must clear the dwsid cookie if one exists. When shopper navigates
     * to SFRA as a logged-in shopper, ECOM notices a missing DWSID, generates a new DWSID and triggers the onSession hook which uses
     * registered shopper refresh-token and restores session and basket on SFRA.
     */
    private clearECOMSession;
    /**
     * Converts a duration in seconds to a Date object.
     * This function takes a number representing seconds and returns a Date object
     * for the current time plus the given duration.
     *
     * @param {number} seconds - The number of seconds to add to the current time.
     * @returns {Date} A Date object for the expiration time.
     */
    private convertSecondsToDate;
    /**
     * Retrieves our refresh token cookie ttl value
     */
    private getRefreshTokenCookieTTLValue;
    /**
     * This method stores the TokenResponse object retrieved from SLAS, and
     * store the data in storage.
     */
    private handleTokenResponse;
    refreshAccessToken(): Promise<ShopperLoginTypes.TokenResponse>;
    /**
     * This method queues the requests and handles the SLAS token response.
     *
     * It returns the queue.
     *
     * @Internal
     */
    queueRequest(fn: () => Promise<TokenResponse>, isGuest: boolean): Promise<ShopperLoginTypes.TokenResponse>;
    logWarning: (msg: string) => void;
    /**
     * This method extracts the status and message from a ResponseError that is returned
     * by commerce-sdk-isomorphic.
     *
     * commerce-sdk-isomorphic throws a `ResponseError`, but doesn't export the class.
     * We can't use `instanceof`, so instead we just check for the `response` property
     * and assume it is a `ResponseError` if a response is present
     *
     * Once commerce-sdk-isomorphic exports `ResponseError` we can revisit if this method is
     * still required.
     *
     * @returns {status_code, responseMessage} contained within the ResponseError
     * @throws error if the error is not a ResponseError
     * @Internal
     */
    extractResponseError: (error: Error) => Promise<{
        status_code: string;
        responseMessage: string;
    }>;
    /**
     * The ready function returns a promise that resolves with valid ShopperLogin
     * token response.
     *
     * When this method is called for the very first time, it initializes the session
     * by following the public client auth flow to get access token for the user.
     * The flow:
     * 1. If we have valid access token - use it
     * 2. If we have valid refresh token - refresh token flow
     * 3. If we have valid TAOB access token - refresh TAOB token flow
     * 4. PKCE flow
     */
    ready(): Promise<ShopperLoginTypes.TokenResponse>;
    /**
     * Creates a function that only executes after a session is initialized.
     * @param fn Function that needs to wait until the session is initialized.
     * @returns Wrapped function
     */
    whenReady<Args extends unknown[], Data>(fn: (...args: Args) => Promise<Data>): (...args: Args) => Promise<Data>;
    /**
     * A wrapper method for commerce-sdk-isomorphic helper: loginGuestUser.
     *
     */
    loginGuestUser(): Promise<ShopperLoginTypes.TokenResponse>;
    /**
     * This is a wrapper method for ShopperCustomer API registerCustomer endpoint.
     *
     */
    register(body: ShopperCustomersTypes.CustomerRegistration): Promise<{
        addresses?: ({
            address1?: string | undefined;
            address2?: string | undefined;
            addressId: string;
            city?: string | undefined;
            companyName?: string | undefined;
            countryCode: string;
            creationDate?: any;
            firstName?: string | undefined;
            fullName?: string | undefined;
            jobTitle?: string | undefined;
            lastModified?: any;
            lastName: string;
            phone?: string | undefined;
            postBox?: string | undefined;
            postalCode?: string | undefined;
            preferred?: boolean | undefined;
            salutation?: string | undefined;
            secondName?: string | undefined;
            stateCode?: string | undefined;
            suffix?: string | undefined;
            suite?: string | undefined;
            title?: string | undefined;
        } & {
            [key: string]: any;
        })[] | undefined;
        authType?: string | undefined;
        birthday?: any;
        companyName?: string | undefined;
        creationDate?: any;
        customerId?: string | undefined;
        customerNo?: string | undefined;
        currentPassword?: string | undefined;
        email?: string | undefined;
        enabled?: boolean | undefined;
        fax?: string | undefined;
        firstName?: string | undefined;
        gender?: number | undefined;
        hashedLogin?: string | undefined;
        jobTitle?: string | undefined;
        lastLoginTime?: any;
        lastModified?: any;
        lastName?: string | undefined;
        lastVisitTime?: any;
        login?: string | undefined;
        note?: string | undefined;
        paymentInstruments?: ({
            bankRoutingNumber?: string | undefined;
            creationDate?: any;
            lastModified?: any;
            maskedGiftCertificateCode?: string | undefined;
            paymentBankAccount?: ({
                driversLicenseLastDigits?: string | undefined;
                driversLicenseStateCode?: string | undefined;
                holder?: string | undefined;
                maskedDriversLicense?: string | undefined;
                maskedNumber?: string | undefined;
                numberLastDigits?: string | undefined;
            } & {
                [key: string]: any;
            }) | undefined;
            paymentCard?: ({
                cardType: string;
                creditCardExpired?: boolean | undefined;
                creditCardToken?: string | undefined;
                expirationMonth?: number | undefined;
                expirationYear?: number | undefined;
                holder?: string | undefined;
                issueNumber?: string | undefined;
                maskedNumber?: string | undefined;
                numberLastDigits?: string | undefined;
                validFromMonth?: number | undefined;
                validFromYear?: number | undefined;
            } & {
                [key: string]: any;
            }) | undefined;
            paymentInstrumentId?: string | undefined;
            paymentMethodId?: string | undefined;
        } & {
            [key: string]: any;
        })[] | undefined;
        phoneBusiness?: string | undefined;
        phoneHome?: string | undefined;
        phoneMobile?: string | undefined;
        preferredLocale?: string | undefined;
        previousLoginTime?: any;
        previousVisitTime?: any;
        salutation?: string | undefined;
        secondName?: string | undefined;
        suffix?: string | undefined;
        title?: string | undefined;
    } & {
        [key: string]: any;
    }>;
    /**
     * A wrapper method for commerce-sdk-isomorphic helper: loginRegisteredUserB2C.
     *
     */
    loginRegisteredUserB2C(credentials: LoginRegisteredUserB2CCredentials): Promise<helpers.TokenResponse>;
    /**
     * Trusted agent authorization
     *
     * @warning This method is not supported on the server, it is a client-only method.
     */
    authorizeTrustedAgent(credentials: {
        loginId?: string;
    }): Promise<{
        url: string;
        codeVerifier: string;
    }>;
    /**
     * Trusted agent login
     *
     * @warning This method is not supported on the server, it is a client-only method.
     */
    loginTrustedAgent(credentials: {
        loginId?: string;
        code: string;
        codeVerifier?: string;
        usid?: string;
        state?: string;
        clientSecret?: string;
    }): Promise<{
        access_token: string;
        id_token: string;
        refresh_token: string;
        expires_in: number;
        refresh_token_expires_in: any;
        token_type: string;
        usid: string;
        customer_id: string;
        enc_user_id: string;
        idp_access_token: string;
    } & {
        [key: string]: any;
    }>;
    /**
     * Trusted agent refresh handler
     *
     * @warning This method is not supported on the server, it is a client-only method.
     */
    registerTrustedAgentRefreshHandler(refreshTrustedAgentHandler: (loginId?: string, usid?: string, refresh?: boolean) => Promise<TokenResponse>): void;
    refreshTrustedAgent(loginId: string, usid: string): Promise<TokenResponse>;
    /**
     * A wrapper method for commerce-sdk-isomorphic helper: logout.
     *
     */
    logout(): Promise<ShopperLoginTypes.TokenResponse>;
    /**
     * Handle updating customer password and re-log in after the access token is invalidated.
     *
     */
    updateCustomerPassword(body: {
        customer: ShopperCustomersTypes.Customer;
        password: string;
        currentPassword: string;
        shouldReloginCurrentSession?: boolean;
    }): Promise<void>;
    /**
     * A wrapper method for commerce-sdk-isomorphic helper: authorizeIDP.
     *
     */
    authorizeIDP(parameters: AuthorizeIDPParams): Promise<void>;
    /**
     * A wrapper method for commerce-sdk-isomorphic helper: loginIDPUser.
     *
     */
    loginIDPUser(parameters: LoginIDPUserParams): Promise<helpers.TokenResponse>;
    /**
     * A wrapper method for commerce-sdk-isomorphic helper: authorizePasswordless.
     */
    authorizePasswordless(parameters: AuthorizePasswordlessParams): Promise<Response>;
    /**
     * A wrapper method for commerce-sdk-isomorphic helper: getPasswordLessAccessToken.
     */
    getPasswordLessAccessToken(parameters: LoginPasswordlessParams): Promise<helpers.TokenResponse>;
    /**
     * A wrapper method for the SLAS endpoint: getPasswordResetToken.
     *
     */
    getPasswordResetToken(parameters: ShopperLoginTypes.PasswordActionRequest): Promise<void>;
    /**
     * A wrapper method for the SLAS endpoint: resetPassword.
     *
     */
    resetPassword(parameters: ShopperLoginTypes.PasswordActionVerifyRequest): Promise<void>;
    /**
     * Decode SLAS JWT and extract information such as customer id, usid, etc.
     *
     */
    parseSlasJWT(jwt: string): {
        isGuest: boolean;
        customerId: string;
        usid: string;
        dnt: string;
        loginId: string;
        isAgent: boolean;
        agentId: string | null;
        uido: string;
    };
}
export default Auth;
//# sourceMappingURL=index.d.ts.map