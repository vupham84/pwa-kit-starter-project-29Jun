"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cacheUpdateMatrix = void 0;
var _queryKeyHelpers = require("./queryKeyHelpers");
var _utils = require("../utils");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * Copyright (c) 2023, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const noop = () => ({});

// ReactQuery type def for the updater function uses type `unknown` for the first param,
// this makes it hard to define the `createUpdateFunction` below, so we created this type.

// This is a slight variation of above, but we know the data is not null.

/**
 * Create an update handler for the cache matrix. This updater will implicitly clone and assert
 * that the data being passed to is is not undefined.
 *
 * @param update
 * @returns
 */
const createUpdateFunction = update => data => data ? update((0, _utils.clone)(data)) : undefined;
const cacheUpdateMatrix = exports.cacheUpdateMatrix = {
  createCustomerAddress(customerId, {
    parameters
  }, response) {
    // getCustomerAddress uses `addressName` rather than `addressId`
    const newParams = _objectSpread(_objectSpread({}, parameters), {}, {
      addressName: response.addressId
    });
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerAddress.queryKey(newParams)
      }, {
        queryKey: _queryKeyHelpers.getCustomer.queryKey(newParams),
        updater: createUpdateFunction(customer => {
          // Push new address onto the end of addresses list.
          customer.addresses = [...(customer.addresses ?? []), response];
          return customer;
        })
      }]
    };
  },
  createCustomerPaymentInstrument(customerId, {
    parameters
  }, response) {
    const newParams = _objectSpread(_objectSpread({}, parameters), {}, {
      paymentInstrumentId: response.paymentInstrumentId
    });
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerPaymentInstrument.queryKey(newParams)
      }, {
        queryKey: _queryKeyHelpers.getCustomer.queryKey(newParams),
        updater: createUpdateFunction(customer => {
          customer.paymentInstruments = [...(customer.paymentInstruments ?? []), response];
          return customer;
        })
      }]
    };
  },
  createCustomerProductList(customerId, {
    parameters
  }, response) {
    // We always invalidate, because even without an ID we assume that something has changed
    const listId = response.id;
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          // if a user has no product list, data will not present in the response.
          if (!result.data) {
            result.data = [response];
          } else {
            // Add new list to front of the lists.
            result.data.unshift(response);
          }
          result.limit++;
          result.total++;
          return result;
        })
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductList.queryKey(_objectSpread(_objectSpread({}, parameters), {}, {
          listId
        }))
      }]
    };
  },
  createCustomerProductListItem(customerId, {
    parameters
  }, response) {
    // We always invalidate, because even without an ID we assume that something has changed
    // QUESTION: Why would we get a response that doesn't have an ID?
    const itemId = response.id;
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductListItem.queryKey(_objectSpread(_objectSpread({}, parameters), {}, {
          itemId
        }))
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductList.queryKey(parameters),
        updater: createUpdateFunction(list => {
          return _objectSpread(_objectSpread({}, list), {}, {
            customerProductListItems: [...((list === null || list === void 0 ? void 0 : list.customerProductListItems) || []), response]
          });
        })
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          // Find the list that we want to add the item to.
          const list = result.data.find(({
            id
          }) => id === parameters.listId);
          if (!list) {
            return;
          }
          list.customerProductListItems = [...(list.customerProductListItems ?? []), response];
          return result;
        })
      }]
    };
  },
  deleteCustomerPaymentInstrument(customerId, {
    parameters
  }) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomer.queryKey(parameters),
        updater: createUpdateFunction(customer => {
          var _customer$paymentInst, _customer$paymentInst2;
          const paymentInstrumentIndex = (_customer$paymentInst = customer.paymentInstruments) === null || _customer$paymentInst === void 0 ? void 0 : _customer$paymentInst.findIndex(({
            paymentInstrumentId
          }) => paymentInstrumentId === parameters.paymentInstrumentId);

          // Return undefined (no changes) if no payment instrument was found.
          if (paymentInstrumentIndex === undefined || paymentInstrumentIndex < 0) {
            return;
          }

          // Remove the found payment instrument.
          (_customer$paymentInst2 = customer.paymentInstruments) === null || _customer$paymentInst2 === void 0 ? void 0 : _customer$paymentInst2.splice(paymentInstrumentIndex, 1);
          return customer;
        })
      }],
      remove: [{
        queryKey: _queryKeyHelpers.getCustomerPaymentInstrument.queryKey(parameters)
      }]
    };
  },
  deleteCustomerProductList(customerId, {
    parameters
  }) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          const listIndex = result.data.findIndex(({
            id
          }) => id === parameters.listId);

          // Return undefined if no list is found
          if (listIndex < 0) {
            return;
          }

          // Remove the list from the result object
          result.data.splice(listIndex, 1);
          result.limit--;
          result.total--;
          return result;
        })
      }],
      remove: [{
        queryKey: _queryKeyHelpers.getCustomerProductList.path(parameters)
      }]
    };
  },
  deleteCustomerProductListItem(customerId, {
    parameters
  }) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductList.queryKey(parameters),
        updater: createUpdateFunction(list => {
          var _list$customerProduct, _list$customerProduct2;
          const itemIndex = (_list$customerProduct = list.customerProductListItems) === null || _list$customerProduct === void 0 ? void 0 : _list$customerProduct.findIndex(({
            id
          }) => id === parameters.itemId);

          // Return undefined if there is no item found.
          if (itemIndex === undefined || itemIndex < 0) {
            return;
          }

          // Remove the list item
          (_list$customerProduct2 = list.customerProductListItems) === null || _list$customerProduct2 === void 0 ? void 0 : _list$customerProduct2.splice(itemIndex, 1);
          return list;
        })
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          var _list$customerProduct3, _list$customerProduct4;
          const list = result.data.find(({
            id
          }) => id === parameters.listId);
          const itemIndex = list === null || list === void 0 ? void 0 : (_list$customerProduct3 = list.customerProductListItems) === null || _list$customerProduct3 === void 0 ? void 0 : _list$customerProduct3.findIndex(({
            id
          }) => id === parameters.itemId);

          // Return undefined if no item was found in the provided list.
          if (itemIndex === undefined || itemIndex < 0) {
            return;
          }

          // Remove the item from the list.
          list === null || list === void 0 ? void 0 : (_list$customerProduct4 = list.customerProductListItems) === null || _list$customerProduct4 === void 0 ? void 0 : _list$customerProduct4.splice(itemIndex, 1);
          return result;
        })
      }],
      remove: [{
        queryKey: _queryKeyHelpers.getCustomerProductListItem.queryKey(parameters)
      }]
    };
  },
  getResetPasswordToken: noop,
  // TODO: Should this update the `getCustomer` cache?
  registerCustomer: noop,
  // TODO: Implement when the endpoint exits closed beta.
  // registerExternalProfile: TODO('registerExternalProfile'),
  removeCustomerAddress(customerId, {
    parameters
  }) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomer.queryKey(parameters),
        updater: createUpdateFunction(customer => {
          var _customer$addresses, _customer$addresses2;
          const addressIndex = (_customer$addresses = customer.addresses) === null || _customer$addresses === void 0 ? void 0 : _customer$addresses.findIndex(({
            addressId
          }) => addressId === parameters.addressName);

          // Return undefined if the address is not found...
          if (addressIndex === undefined || addressIndex < 0) {
            return;
          }

          // Remove the found address.
          (_customer$addresses2 = customer.addresses) === null || _customer$addresses2 === void 0 ? void 0 : _customer$addresses2.splice(addressIndex, 1);
          return customer;
        })
      }],
      remove: [{
        queryKey: _queryKeyHelpers.getCustomerAddress.queryKey(parameters)
      }]
    };
  },
  resetPassword: noop,
  updateCustomer(customerId, {
    parameters
  }, response) {
    // When we update a customer, we don't know what data has changed, so we must invalidate all
    // derivative endpoints. They conveniently all start with the same path as `getCustomer`,
    // but we do NOT want to invalidate `getCustomer` itself, we want to _update_ it. (Ideally,
    // we could invalidate *then* update, but React Query can't handle that.) To do so, we
    // examine the path of each cached query. If it starts with the `getCustomer` path, we
    // invalidate, UNLESS the first item afer the path is an object, because that means that it
    // is the `getCustomer` query itself.
    const path = _queryKeyHelpers.getCustomer.path(parameters);
    const isNotGetCustomer = ({
      queryKey
    }) => typeof queryKey[path.length] !== 'object';
    const predicate = (0, _utils.and)((0, _utils.pathStartsWith)(path), isNotGetCustomer);
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomer.queryKey(parameters),
        updater: createUpdateFunction(customer => {
          // The `updateCustomer` endpoint does not return exhaustive customer data. It
          // is missing data for `addresses` and `paymentInstruments`, to name a few. Here
          // we ensure that any customer data we have is preserved.
          return _objectSpread(_objectSpread({}, customer), response);
        })
      }],
      invalidate: [{
        predicate
      }]
    };
  },
  updateCustomerAddress(customerId, {
    parameters
  }, response) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerAddress.queryKey(parameters)
      }, {
        queryKey: _queryKeyHelpers.getCustomer.queryKey(parameters),
        updater: createUpdateFunction(customer => {
          if (!customer.addresses) return;
          const addressIndex = customer.addresses.findIndex(({
            addressId
          }) => addressId === response.addressId);

          // Return undefined if no address is found...
          if (addressIndex === undefined || addressIndex < 0) {
            return;
          }

          // Update the found address.
          customer.addresses[addressIndex] = response;
          return customer;
        })
      }]
    };
  },
  updateCustomerPassword: noop,
  updateCustomerProductList(customerId, {
    parameters
  }, response) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductList.queryKey(parameters)
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          const listIndex = result.data.findIndex(({
            id
          }) => id === response.id);

          // Return undefined if we didn't find the product list we were looking for.
          if (listIndex < 0) {
            return;
          }

          // Update the product list.
          result.data[listIndex] = response;
          return result;
        })
      }]
    };
  },
  updateCustomerProductListItem(customerId, {
    parameters
  }, response) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductListItem.queryKey(parameters)
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductList.queryKey(parameters),
        updater: createUpdateFunction(list => {
          var _list$customerProduct5;
          if (!list.customerProductListItems) return;
          // Find the index of the item we want to update.
          const itemIndex = (_list$customerProduct5 = list.customerProductListItems) === null || _list$customerProduct5 === void 0 ? void 0 : _list$customerProduct5.findIndex(({
            id
          }) => id === parameters.itemId);

          // Return undefined when item isn't found.
          if (itemIndex === undefined || itemIndex < 0) {
            return;
          }
          list.customerProductListItems[itemIndex] = response;
          return list;
        })
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          // Find the list with the current list id.
          const listIndex = result.data.findIndex(({
            id
          }) => id === parameters.listId);
          // Find the index of the item in the list.
          const items = result.data[listIndex].customerProductListItems;
          if (!items) return;
          const itemIndex = items.findIndex(({
            id
          }) => id === parameters.itemId);

          // Return undefined if item isn't found...
          if (itemIndex === undefined || itemIndex < 0) return;

          // Update the item in the found list.
          // NOTE: We know that there is an item to update given the item index is > -1
          items[itemIndex] = response;
          return result;
        })
      }]
    };
  }
};