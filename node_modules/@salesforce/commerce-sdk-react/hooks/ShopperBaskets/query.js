"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTaxesFromBasket = exports.useShippingMethodsForShipment = exports.usePriceBooksForBasket = exports.usePaymentMethodsForBasket = exports.useBasket = void 0;
var _useCommerceApi = _interopRequireDefault(require("../useCommerceApi"));
var _useQuery = require("../useQuery");
var _utils = require("../utils");
var queryKeyHelpers = _interopRequireWildcard(require("./queryKeyHelpers"));
var _commerceSdkIsomorphic = require("commerce-sdk-isomorphic");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; } /*
 * Copyright (c) 2023, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/**
 * Gets a basket.
 * @group ShopperBaskets
 * @category Query
 * @parameter apiOptions - Options to pass through to `commerce-sdk-isomorphic`, with `null` accepted for unset API parameters.
 * @parameter queryOptions - TanStack Query query options, with `enabled` by default set to check that all required API parameters have been set.
 * @returns A TanStack Query query hook with data from the Shopper Baskets `getBasket` endpoint.
 * @see {@link https://developer.salesforce.com/docs/commerce/commerce-api/references/shopper-baskets?meta=getBasket| Salesforce Developer Center} for more information about the API endpoint.
 * @see {@link https://salesforcecommercecloud.github.io/commerce-sdk-isomorphic/classes/shopperbaskets.shopperbaskets-1.html#getbasket | `commerce-sdk-isomorphic` documentation} for more information on the parameters and returned data type.
 * @see {@link https://tanstack.com/query/latest/docs/react/reference/useQuery | TanStack Query `useQuery` reference} for more information about the return value.
 */
const useBasket = (apiOptions, queryOptions = {}) => {
  const {
    shopperBaskets: client
  } = (0, _useCommerceApi.default)();
  const methodName = 'getBasket';
  const requiredParameters = _commerceSdkIsomorphic.ShopperBaskets.paramKeys[`${methodName}Required`];

  // Parameters can be set in `apiOptions` or `client.clientConfig`;
  // we must merge them in order to generate the correct query key.
  const netOptions = (0, _utils.omitNullableParameters)((0, _utils.mergeOptions)(client, apiOptions));
  const parameters = (0, _utils.pickValidParams)(netOptions.parameters, _commerceSdkIsomorphic.ShopperBaskets.paramKeys[methodName]);
  const queryKey = queryKeyHelpers[methodName].queryKey(netOptions.parameters);
  // We don't use `netOptions` here because we manipulate the options in `useQuery`.
  const method = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (options) {
      return yield client[methodName](options);
    });
    return function method(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  queryOptions.meta = _objectSpread({
    displayName: 'useBasket'
  }, queryOptions.meta);

  // For some reason, if we don't explicitly set these generic parameters, the inferred type for
  // `Data` sometimes, but not always, includes `Response`, which is incorrect. I don't know why.
  return (0, _useQuery.useQuery)(_objectSpread(_objectSpread({}, netOptions), {}, {
    parameters
  }), queryOptions, {
    method,
    queryKey,
    requiredParameters
  });
};
/**
 * Gets applicable payment methods for an existing basket considering the open payment amount only.
 * @group ShopperBaskets
 * @category Query
 * @parameter apiOptions - Options to pass through to `commerce-sdk-isomorphic`, with `null` accepted for unset API parameters.
 * @parameter queryOptions - TanStack Query query options, with `enabled` by default set to check that all required API parameters have been set.
 * @returns A TanStack Query query hook with data from the Shopper Baskets `getPaymentMethodsForBasket` endpoint.
 * @see {@link https://developer.salesforce.com/docs/commerce/commerce-api/references/shopper-baskets?meta=getPaymentMethodsForBasket| Salesforce Developer Center} for more information about the API endpoint.
 * @see {@link https://salesforcecommercecloud.github.io/commerce-sdk-isomorphic/classes/shopperbaskets.shopperbaskets-1.html#getpaymentmethodsforbasket | `commerce-sdk-isomorphic` documentation} for more information on the parameters and returned data type.
 * @see {@link https://tanstack.com/query/latest/docs/react/reference/useQuery | TanStack Query `useQuery` reference} for more information about the return value.
 */
exports.useBasket = useBasket;
const usePaymentMethodsForBasket = (apiOptions, queryOptions = {}) => {
  const {
    shopperBaskets: client
  } = (0, _useCommerceApi.default)();
  const methodName = 'getPaymentMethodsForBasket';
  const requiredParameters = _commerceSdkIsomorphic.ShopperBaskets.paramKeys[`${methodName}Required`];

  // Parameters can be set in `apiOptions` or `client.clientConfig`;
  // we must merge them in order to generate the correct query key.
  const netOptions = (0, _utils.omitNullableParameters)((0, _utils.mergeOptions)(client, apiOptions));
  const parameters = (0, _utils.pickValidParams)(netOptions.parameters, _commerceSdkIsomorphic.ShopperBaskets.paramKeys[methodName]);
  const queryKey = queryKeyHelpers[methodName].queryKey(netOptions.parameters);
  // We don't use `netOptions` here because we manipulate the options in `useQuery`.
  const method = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (options) {
      return yield client[methodName](options);
    });
    return function method(_x2) {
      return _ref2.apply(this, arguments);
    };
  }();
  queryOptions.meta = _objectSpread({
    displayName: 'usePaymentMethodsForBasket'
  }, queryOptions.meta);

  // For some reason, if we don't explicitly set these generic parameters, the inferred type for
  // `Data` sometimes, but not always, includes `Response`, which is incorrect. I don't know why.
  return (0, _useQuery.useQuery)(_objectSpread(_objectSpread({}, netOptions), {}, {
    parameters
  }), queryOptions, {
    method,
    queryKey,
    requiredParameters
  });
};
/**
 * Gets applicable price books for an existing basket.
 * @group ShopperBaskets
 * @category Query
 * @parameter apiOptions - Options to pass through to `commerce-sdk-isomorphic`, with `null` accepted for unset API parameters.
 * @parameter queryOptions - TanStack Query query options, with `enabled` by default set to check that all required API parameters have been set.
 * @returns A TanStack Query query hook with data from the Shopper Baskets `getPriceBooksForBasket` endpoint.
 * @see {@link https://developer.salesforce.com/docs/commerce/commerce-api/references/shopper-baskets?meta=getPriceBooksForBasket| Salesforce Developer Center} for more information about the API endpoint.
 * @see {@link https://salesforcecommercecloud.github.io/commerce-sdk-isomorphic/classes/shopperbaskets.shopperbaskets-1.html#getpricebooksforbasket | `commerce-sdk-isomorphic` documentation} for more information on the parameters and returned data type.
 * @see {@link https://tanstack.com/query/latest/docs/react/reference/useQuery | TanStack Query `useQuery` reference} for more information about the return value.
 */
exports.usePaymentMethodsForBasket = usePaymentMethodsForBasket;
const usePriceBooksForBasket = (apiOptions, queryOptions = {}) => {
  const {
    shopperBaskets: client
  } = (0, _useCommerceApi.default)();
  const methodName = 'getPriceBooksForBasket';
  const requiredParameters = _commerceSdkIsomorphic.ShopperBaskets.paramKeys[`${methodName}Required`];

  // Parameters can be set in `apiOptions` or `client.clientConfig`;
  // we must merge them in order to generate the correct query key.
  const netOptions = (0, _utils.omitNullableParameters)((0, _utils.mergeOptions)(client, apiOptions));
  const parameters = (0, _utils.pickValidParams)(netOptions.parameters, _commerceSdkIsomorphic.ShopperBaskets.paramKeys[methodName]);
  const queryKey = queryKeyHelpers[methodName].queryKey(netOptions.parameters);
  // We don't use `netOptions` here because we manipulate the options in `useQuery`.
  const method = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(function* (options) {
      return yield client[methodName](options);
    });
    return function method(_x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  queryOptions.meta = _objectSpread({
    displayName: 'usePriceBooksForBasket'
  }, queryOptions.meta);

  // For some reason, if we don't explicitly set these generic parameters, the inferred type for
  // `Data` sometimes, but not always, includes `Response`, which is incorrect. I don't know why.
  return (0, _useQuery.useQuery)(_objectSpread(_objectSpread({}, netOptions), {}, {
    parameters
  }), queryOptions, {
    method,
    queryKey,
    requiredParameters
  });
};
/**
 * Gets the applicable shipping methods for a certain shipment of a basket.
 * @group ShopperBaskets
 * @category Query
 * @parameter apiOptions - Options to pass through to `commerce-sdk-isomorphic`, with `null` accepted for unset API parameters.
 * @parameter queryOptions - TanStack Query query options, with `enabled` by default set to check that all required API parameters have been set.
 * @returns A TanStack Query query hook with data from the Shopper Baskets `getShippingMethodsForShipment` endpoint.
 * @see {@link https://developer.salesforce.com/docs/commerce/commerce-api/references/shopper-baskets?meta=getShippingMethodsForShipment| Salesforce Developer Center} for more information about the API endpoint.
 * @see {@link https://salesforcecommercecloud.github.io/commerce-sdk-isomorphic/classes/shopperbaskets.shopperbaskets-1.html#getshippingmethodsforshipment | `commerce-sdk-isomorphic` documentation} for more information on the parameters and returned data type.
 * @see {@link https://tanstack.com/query/latest/docs/react/reference/useQuery | TanStack Query `useQuery` reference} for more information about the return value.
 */
exports.usePriceBooksForBasket = usePriceBooksForBasket;
const useShippingMethodsForShipment = (apiOptions, queryOptions = {}) => {
  const {
    shopperBaskets: client
  } = (0, _useCommerceApi.default)();
  const methodName = 'getShippingMethodsForShipment';
  const requiredParameters = _commerceSdkIsomorphic.ShopperBaskets.paramKeys[`${methodName}Required`];

  // Parameters can be set in `apiOptions` or `client.clientConfig`;
  // we must merge them in order to generate the correct query key.
  const netOptions = (0, _utils.omitNullableParameters)((0, _utils.mergeOptions)(client, apiOptions));
  const parameters = (0, _utils.pickValidParams)(netOptions.parameters, _commerceSdkIsomorphic.ShopperBaskets.paramKeys[methodName]);
  const queryKey = queryKeyHelpers[methodName].queryKey(netOptions.parameters);
  // We don't use `netOptions` here because we manipulate the options in `useQuery`.
  const method = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(function* (options) {
      return yield client[methodName](options);
    });
    return function method(_x4) {
      return _ref4.apply(this, arguments);
    };
  }();
  queryOptions.meta = _objectSpread({
    displayName: 'useShippingMethodsForShipment'
  }, queryOptions.meta);

  // For some reason, if we don't explicitly set these generic parameters, the inferred type for
  // `Data` sometimes, but not always, includes `Response`, which is incorrect. I don't know why.
  return (0, _useQuery.useQuery)(_objectSpread(_objectSpread({}, netOptions), {}, {
    parameters
  }), queryOptions, {
    method,
    queryKey,
    requiredParameters
  });
};
/**
 * This method gives you the external taxation data set by the PUT taxes API. This endpoint can be called only if external taxation mode was used for basket creation. See POST /baskets for more information.
 * @group ShopperBaskets
 * @category Query
 * @parameter apiOptions - Options to pass through to `commerce-sdk-isomorphic`, with `null` accepted for unset API parameters.
 * @parameter queryOptions - TanStack Query query options, with `enabled` by default set to check that all required API parameters have been set.
 * @returns A TanStack Query query hook with data from the Shopper Baskets `getTaxesFromBasket` endpoint.
 * @see {@link https://developer.salesforce.com/docs/commerce/commerce-api/references/shopper-baskets?meta=getTaxesFromBasket| Salesforce Developer Center} for more information about the API endpoint.
 * @see {@link https://salesforcecommercecloud.github.io/commerce-sdk-isomorphic/classes/shopperbaskets.shopperbaskets-1.html#gettaxesfrombasket | `commerce-sdk-isomorphic` documentation} for more information on the parameters and returned data type.
 * @see {@link https://tanstack.com/query/latest/docs/react/reference/useQuery | TanStack Query `useQuery` reference} for more information about the return value.
 */
exports.useShippingMethodsForShipment = useShippingMethodsForShipment;
const useTaxesFromBasket = (apiOptions, queryOptions = {}) => {
  const {
    shopperBaskets: client
  } = (0, _useCommerceApi.default)();
  const methodName = 'getTaxesFromBasket';
  const requiredParameters = _commerceSdkIsomorphic.ShopperBaskets.paramKeys[`${methodName}Required`];

  // Parameters can be set in `apiOptions` or `client.clientConfig`;
  // we must merge them in order to generate the correct query key.
  const netOptions = (0, _utils.omitNullableParameters)((0, _utils.mergeOptions)(client, apiOptions));
  const parameters = (0, _utils.pickValidParams)(netOptions.parameters, _commerceSdkIsomorphic.ShopperBaskets.paramKeys[methodName]);
  const queryKey = queryKeyHelpers[methodName].queryKey(netOptions.parameters);
  // We don't use `netOptions` here because we manipulate the options in `useQuery`.
  const method = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator(function* (options) {
      return yield client[methodName](options);
    });
    return function method(_x5) {
      return _ref5.apply(this, arguments);
    };
  }();
  queryOptions.meta = _objectSpread({
    displayName: 'useTaxesFromBasket'
  }, queryOptions.meta);

  // For some reason, if we don't explicitly set these generic parameters, the inferred type for
  // `Data` sometimes, but not always, includes `Response`, which is incorrect. I don't know why.
  return (0, _useQuery.useQuery)(_objectSpread(_objectSpread({}, netOptions), {}, {
    parameters
  }), queryOptions, {
    method,
    queryKey,
    requiredParameters
  });
};
exports.useTaxesFromBasket = useTaxesFromBasket;