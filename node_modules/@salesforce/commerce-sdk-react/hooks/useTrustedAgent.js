"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.createTrustedAgentPopup = void 0;
var _react = require("react");
var _reactQuery = require("@tanstack/react-query");
var _useAuthContext = _interopRequireDefault(require("./useAuthContext"));
var _utils = require("../utils");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; } /*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
let popup;
let intervalId;
const getCodeAndStateValueFromPopup = popup => {
  let code = null;
  let state = null;
  try {
    var _popup$location;
    const url = new URL((popup === null || popup === void 0 ? void 0 : (_popup$location = popup.location) === null || _popup$location === void 0 ? void 0 : _popup$location.toString()) || 'http://localhost');
    code = url.searchParams.get('code');
    state = url.searchParams.get('state');
  } catch (e) {
    /* here to catch invalid URL or crossdomain popup access errors */
  }
  return {
    code,
    state
  };
};
const createTrustedAgentPopup = exports.createTrustedAgentPopup = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (url, isRefresh = false, timeoutMinutes = 5, refreshTimeoutFocusMinutes = 1) {
    var _window, _window$open;
    // if a popup already exists, close it
    if (popup) {
      var _popup;
      (_popup = popup) === null || _popup === void 0 ? void 0 : _popup.close();
    }

    // if a timer already exists, clear it
    if (intervalId) {
      clearTimeout(intervalId);
    }

    // create our popup
    popup = ((_window = window) === null || _window === void 0 ? void 0 : (_window$open = _window.open) === null || _window$open === void 0 ? void 0 : _window$open.call(_window, url, 'accountManagerPopup', 'popup=true,width=800,height=800,scrollbars=false,status=false,location=false,menubar=false,toolbar=false')) || null;

    // if this is intended to be a behind the
    // scenes refresh call, make sure our main
    // window stays focused
    if (isRefresh) {
      var _window2, _window2$focus;
      (_window2 = window) === null || _window2 === void 0 ? void 0 : (_window2$focus = _window2.focus) === null || _window2$focus === void 0 ? void 0 : _window2$focus.call(_window2);
    }
    const startTime = Date.now();
    return new Promise((resolve, reject) => {
      const checkPopupState = () => {
        var _popup3;
        const popupCouldntInitialize = !popup;
        if (popupCouldntInitialize) {
          clearTimeout(intervalId);
          return reject("Popup couldn't initialize. Check your popup blocker.");
        }

        // success state
        const {
          code,
          state
        } = getCodeAndStateValueFromPopup(popup);
        if (code && state) {
          var _popup2;
          clearTimeout(intervalId);
          (_popup2 = popup) === null || _popup2 === void 0 ? void 0 : _popup2.close();
          return resolve({
            code,
            state
          });
        }
        const popupClosedWithoutAuthenticating = (_popup3 = popup) === null || _popup3 === void 0 ? void 0 : _popup3.closed;
        if (popupClosedWithoutAuthenticating) {
          clearTimeout(intervalId);
          return reject('Popup closed without authenticating.');
        }
        const popupTimeoutOccurred = Math.floor(Date.now() - startTime) > timeoutMinutes * 1000 * 60;
        if (popupTimeoutOccurred) {
          var _popup4;
          clearTimeout(intervalId);
          (_popup4 = popup) === null || _popup4 === void 0 ? void 0 : _popup4.close();
          return reject(`Popup timed out after ${timeoutMinutes} minutes.`);
        }

        // if our refresh flow is stuck, focus the popup window
        const popupRefreshTimeoutOccurred = Math.floor(Date.now() - startTime) > refreshTimeoutFocusMinutes * 1000 * 60;
        if (isRefresh && popupRefreshTimeoutOccurred) {
          var _popup5;
          (_popup5 = popup) === null || _popup5 === void 0 ? void 0 : _popup5.focus();
        }
      };
      checkPopupState();
      intervalId = setInterval(checkPopupState, 1000);
    });
  });
  return function createTrustedAgentPopup(_x) {
    return _ref.apply(this, arguments);
  };
}();

/**
 * A hook to return trusted agent state.
 *
 * @group Helpers
 * @category Shopper Authentication
 * @experimental
 *
 */
const useTrustedAgent = () => {
  const auth = (0, _useAuthContext.default)();
  const [isAgent, setIsAgent] = (0, _react.useState)(false);
  const [agentId, setAgentId] = (0, _react.useState)('');
  const [loginId, setLoginId] = (0, _react.useState)('');
  const authorizeTrustedAgent = (0, _reactQuery.useMutation)(auth.authorizeTrustedAgent.bind(auth));
  const loginTrustedAgent = (0, _reactQuery.useMutation)(auth.loginTrustedAgent.bind(auth));
  const logoutTrustedAgent = (0, _reactQuery.useMutation)(auth.logout.bind(auth));
  const login = (0, _react.useCallback)( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (loginId, usid, refresh = false) {
      if (!(0, _utils.onClient)()) {
        throw new Error('Something went wrong, this client side method is invoked on the server.');
      }
      const {
        url,
        codeVerifier
      } = yield authorizeTrustedAgent.mutateAsync({
        loginId
      });
      const {
        code,
        state
      } = yield createTrustedAgentPopup(url, refresh);
      return yield loginTrustedAgent.mutateAsync({
        loginId,
        code,
        codeVerifier,
        state,
        usid
      });
    });
    return function (_x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }(), [auth]);
  const logout = (0, _react.useCallback)( /*#__PURE__*/_asyncToGenerator(function* () {
    return yield logoutTrustedAgent.mutateAsync();
  }), [auth]);
  (0, _react.useEffect)(() => {
    auth.registerTrustedAgentRefreshHandler(login);
  }, [auth]);
  (0, _react.useEffect)(() => {
    try {
      const {
        isAgent,
        agentId,
        loginId
      } = auth.parseSlasJWT(auth.get('access_token'));
      setIsAgent(isAgent);
      setAgentId(agentId || '');
      setLoginId(loginId);
    } catch (e) {
      /* here to catch invalid jwt errors */
    }
  }, [auth.get('access_token')]);
  return {
    isAgent,
    agentId,
    loginId,
    login,
    logout
  };
};
var _default = exports.default = useTrustedAgent;