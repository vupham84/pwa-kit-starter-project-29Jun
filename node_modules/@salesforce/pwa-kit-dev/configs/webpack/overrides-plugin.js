"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _path = _interopRequireDefault(require("path"));
var _glob = _interopRequireDefault(require("glob"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/*
 * Copyright (c) 2023, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */

/**
 * @class OverridesResolverPlugin
 *
 *  This plugin provides the "Overrides" behavior of the Template Extensibility feature,
 *  allowing third party implementations that depend on an npm module for the base implementation
 *  and then overriding only specific files
 */
class OverridesResolverPlugin {
  /**
   *
   * @param options
   * @param {string} options.overridesDir path to application base
   * @param {string[]} options.overrides paths to overrides
   * @param {string} options.projectDir path to project directory
   */
  constructor(options) {
    var _options$overridesDir, _options$projectDir, _this$pkg, _this$pkg$ccExtensibi, _this$pkg$ccExtensibi2, _this$pkg$ccExtensibi3, _this$pkg2, _this$pkg2$ccExtensib;
    // always coerce to posix fs paths, as glob sync and es6 imports don't use windows paths
    this.overridesDir = ((_options$overridesDir = options.overridesDir) === null || _options$overridesDir === void 0 ? void 0 : _options$overridesDir.replace(/\\/g, '/')) || '';
    this.extends = options.extends || [];
    // always coerce to posix fs paths, as glob sync and es6 imports don't use windows paths
    this.projectDir = (_options$projectDir = options.projectDir) === null || _options$projectDir === void 0 ? void 0 : _options$projectDir.replace(/\\/g, '/');
    this._allSearchDirs = [this.projectDir + this.overridesDir, ...this.extends];
    this.pkg = require(_path.default.resolve(this.projectDir, 'package.json'));
    this.extendsHashMap = new Map();

    // everything except directories
    // NOTE that the glob library expects posix so we replace windows file paths here
    const globPattern = `${(_this$pkg = this.pkg) === null || _this$pkg === void 0 ? void 0 : (_this$pkg$ccExtensibi = _this$pkg.ccExtensibility) === null || _this$pkg$ccExtensibi === void 0 ? void 0 : (_this$pkg$ccExtensibi2 = _this$pkg$ccExtensibi.overridesDir) === null || _this$pkg$ccExtensibi2 === void 0 ? void 0 : (_this$pkg$ccExtensibi3 = _this$pkg$ccExtensibi2.replace(/\\/g, '/')) === null || _this$pkg$ccExtensibi3 === void 0 ? void 0 : _this$pkg$ccExtensibi3.replace(/^\//, '')}/**/*.*`;
    const overridesFsRead = _glob.default.sync(globPattern);
    const overrideReplace = ((_this$pkg2 = this.pkg) === null || _this$pkg2 === void 0 ? void 0 : (_this$pkg2$ccExtensib = _this$pkg2.ccExtensibility) === null || _this$pkg2$ccExtensib === void 0 ? void 0 : _this$pkg2$ccExtensib.overridesDir) + '/';

    // For each filepath in the overrides directory:
    // Split it in one of two ways:
    // If the filepath is like /pages/home/index.js,
    //    split on index and 'key' is /pages/home/
    // If the filepath is like /pages/home/data.js,
    //    split on the . and 'key' is /pages/home/data
    // The negative lookaheads ensure the split occurs on the last occurence of .
    //    This avoids collisions when both index.js and index.test.js are
    //    present in the same directory
    overridesFsRead.forEach(item => {
      const end = item.substring(item.lastIndexOf('/index'));
      const [key, ...rest] = item.split(/(index(?!(\.[^.]*\.))|\.(?!([^.]*\.)))/);
      this.extendsHashMap.set(key.replace(overrideReplace, '').replace(/\/$/, ''), [end, rest.filter(Boolean)]);
    });
  }
  /**
   * This takes an import with the overrides dir / extends package removed and finds
   * the corresponding path from overridesFsRead
   *
   * Ie. Given an import @salesforce/retail-react-app/app/components/header,
   * requestPath is app/components/header
   *
   * @param requestPath - relative import path
   * @param dirs - this._allSearchDirs
   */
  findFileFromMap(requestPath, dirs) {
    const fileExt = _path.default.extname(requestPath);
    for (const dir of dirs) {
      let base = _path.default.join(dir, requestPath);
      if (fileExt) {
        const noExtPath = requestPath.replace(fileExt, '');
        if (this.extendsHashMap.has(noExtPath)) {
          return base;
        }
      } else {
        if (this.extendsHashMap.has(requestPath)) {
          const end = this.extendsHashMap.get(requestPath)[1];
          const isRequestingIndex = end[0] === 'index';
          let result = (base === null || base === void 0 ? void 0 : base.replace(/$\//, '')) + end.join('');
          if (isRequestingIndex) {
            result = _path.default.join(base, this.extendsHashMap.get(requestPath)[1].join(''));
          }
          return result;
        }
      }
    }
  }

  /*
      Given an import request, this function removes the override dir
      or the package name defined in extends.
       For example:
      import * from 'src/configs/webpack/test/overrides/path/data.js resolves to
          path/data.js
      import * from '@salesforce/retail-react-app/app/component/header resolves to
          app/component/header
       TODO: This function is only called if isFromExtends is true. In other words,
      this function is only called if the import request contains a package in extends
      We can probably simplify this function or rename it
  */
  toOverrideRelative(filepath) {
    const override = this._allSearchDirs.find(dir => {
      return filepath.indexOf(dir) === 0;
    });
    return filepath.substring((override === null || override === void 0 ? void 0 : override.length) + 1);
  }

  /*
      Helper function that returns true only if the import request points to a package in 'extends'
      and the issuer path (the file making the import request) is not located in the overrides dir.
       If true, we re-route the import request to the overrides dir.
      If false, the import request proceeds to the base package in node_modules
       For example, given an import request to a package defined in 'extends'
          (ie. @salesforce/retail-react-app):
      This will return true if the issuer is a file in a base template
      This will return false if the issuer is a file in the overrides dir
       This allow the base template to import from overrides and allows the overrides to import from
      the base template using the same syntax (ie. import from @salesforce/retail-react-app/...)
  */
  isFromExtends(request, filepath) {
    var _this$extends, _this$extends$, _this$extends$$starts;
    const pkgName = request.split(/(\/|\\)/).filter(item => !item.match(/(\/|\\)/)).slice(0, (_this$extends = this.extends) !== null && _this$extends !== void 0 && (_this$extends$ = _this$extends[0]) !== null && _this$extends$ !== void 0 && (_this$extends$$starts = _this$extends$.startsWith) !== null && _this$extends$$starts !== void 0 && _this$extends$$starts.call(_this$extends$, '@') ? 2 : 1).join('/');

    // we split by path delimeters (OS agnostic), filter out
    // separators, then spread both to form a normalized
    // '/base', 'path', 'to', 'dir' when both halves are joined
    const issuerPath = _path.default.join(...this.projectDir.split(_path.default.sep).filter(item => !item.match(/(\/|\\)/)), ...this.overridesDir.replace(/^(\/|\\)/, '').split('/').filter(item => !item.match(/(\/|\\)/)));
    return (
      // request includes extends
      this.extends.includes(pkgName) &&
      //
      // this is very important, to avoid circular imports, check that the
      // `issuer` (requesting context) isn't the overrides directory

      // request is not issued from overrides
      !filepath.includes(issuerPath)
    );
  }
  handleHook(requestContext, resolveContext, callback, resolver) {
    let targetFile;
    let overrideRelative;
    if (this.isFromExtends(requestContext.request, requestContext.path)) {
      overrideRelative = this.toOverrideRelative(requestContext.request).replace(/$\//, '');
      targetFile = this.findFileFromMap(overrideRelative, this._allSearchDirs);
    }
    if (targetFile) {
      const target = resolver.ensureHook('resolved');
      requestContext.path = _path.default.sep === '/' ? targetFile : targetFile.replace('/', _path.default.sep);
      resolver.doResolve(target, requestContext, `${this.constructor.name} found base override file`, resolveContext, callback);
    } else {
      return callback();
    }
  }
  apply(resolver) {
    resolver.getHook('resolve').tapAsync('FeatureResolverPlugin', (requestContext, resolveContext, callback) => {
      this.handleHook(requestContext, resolveContext, callback, resolver);
    });
  }
}
var _default = exports.default = OverridesResolverPlugin;