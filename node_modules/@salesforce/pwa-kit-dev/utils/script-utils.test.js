"use strict";

var _fsExtra = require("fs-extra");
var _child_process = require("child_process");
var _path = _interopRequireDefault(require("path"));
var _os = _interopRequireDefault(require("os"));
var scriptUtils = _interopRequireWildcard(require("./script-utils"));
var dependencyTreeMockData = _interopRequireWildcard(require("./mocks/dependency-tree-mock-data"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const pkg = (0, _fsExtra.readJsonSync)(_path.default.join(__dirname, '../package.json'));
let actualReadJson;
let actualExecSync;
jest.mock('fs-extra', () => {
  const originalModule = jest.requireActual('fs-extra');
  actualReadJson = originalModule.readJson;
  return _objectSpread(_objectSpread({}, originalModule), {}, {
    readJson: jest.fn()
  });
});
jest.mock('child_process', () => {
  const originalModule = jest.requireActual('child_process');
  actualExecSync = originalModule.execSync;
  return _objectSpread(_objectSpread({}, originalModule), {}, {
    execSync: jest.fn()
  });
});
describe('scriptUtils', () => {
  const originalEnv = process.env;
  let tmpDir;
  beforeEach( /*#__PURE__*/_asyncToGenerator(function* () {
    process.env = _objectSpread({}, originalEnv);
    tmpDir = yield (0, _fsExtra.mkdtemp)(_path.default.join(_os.default.tmpdir(), 'scriptUtils-tests'));
    // This is a workaround for jest.spyOn(), since I guess it doesn't work with our imports?
    // In any case, using the actual implementation by default prevents subtle bugs in tests.
    _fsExtra.readJson.mockReset().mockImplementation(actualReadJson);
    _child_process.execSync.mockReset().mockImplementation(actualExecSync);
  }));
  afterEach( /*#__PURE__*/_asyncToGenerator(function* () {
    process.env = originalEnv;
    tmpDir && (yield (0, _fsExtra.rm)(tmpDir, {
      recursive: true
    }));
    jest.resetAllMocks();
  }));
  test('glob() with no patterns matches nothing', () => {
    const matcher = scriptUtils.glob();
    expect(matcher('')).toBe(false);
    expect(matcher('a.js')).toBe(false);
    expect(matcher()).toBe(false);
  });
  describe('glob() filters correctly', () => {
    const patterns = ['ssr.js', '**/*.jpg', '!**/no.jpg', 'abc.{js,jsx}'];
    const matcher = scriptUtils.glob(patterns);

    // Paths we expect to match
    const expectToMatch = ['ssr.js', 'test1.jpg', 'static/test2.jpg', 'static/assets/test3.jpg', 'abc.js', 'abc.jsx'];
    expectToMatch.forEach(path => test(`Expect path "${path}" to match`, () => {
      expect(matcher(path)).toBe(true);
    }));

    // Paths we expect not to match
    const expectNotToMatch = ['ssrxjs', 'subdirectory/ssr.js', 'no.jpg', 'static/no.jpg', 'abc.jsz'];
    expectNotToMatch.forEach(path => test(`Expect path "${path}" to NOT match`, () => {
      expect(matcher(path)).toBe(false);
    }));
    const allPaths = expectToMatch.concat(expectNotToMatch);
    test('glob works with Array.filter', () => {
      const matched = allPaths.filter(matcher);
      expect(matched).toHaveLength(expectToMatch.length);
    });
  });
  describe('CloudAPIClient', () => {
    const username = 'user123';
    const api_key = '123';
    const encoded = Buffer.from(`${username}:${api_key}`, 'binary').toString('base64');
    const expectedAuthHeader = {
      Authorization: `Basic ${encoded}`
    };
    test('getAuthHeader', /*#__PURE__*/_asyncToGenerator(function* () {
      const client = new scriptUtils.CloudAPIClient({
        credentials: {
          username,
          api_key
        }
      });
      expect(client.getAuthHeader()).toEqual(expectedAuthHeader);
    }));
    test('getHeaders', /*#__PURE__*/_asyncToGenerator(function* () {
      _fsExtra.readJson.mockReturnValue(pkg);
      const client = new scriptUtils.CloudAPIClient({
        credentials: {
          username,
          api_key
        }
      });
      expect(yield client.getHeaders()).toEqual(_objectSpread({
        'User-Agent': `${pkg.name}@${pkg.version}`
      }, expectedAuthHeader));
    }));
  });
  describe('getPkgJSON', () => {
    test('should work', /*#__PURE__*/_asyncToGenerator(function* () {
      _fsExtra.readJson.mockReturnValue(pkg);
      const pkgJson = yield scriptUtils.getPkgJSON();
      expect(pkgJson.name).toBe('@salesforce/pwa-kit-dev');
    }));
    test('should return default package.json data when no valid file is found', /*#__PURE__*/_asyncToGenerator(function* () {
      _fsExtra.readJson.mockRejectedValue(Error);
      const result = yield scriptUtils.getPkgJSON();
      expect(result).toEqual({
        name: '@salesforce/pwa-kit-dev',
        version: 'unknown'
      });
    }));
  });
  describe('getProjectPkg', () => {
    test('should work', /*#__PURE__*/_asyncToGenerator(function* () {
      _fsExtra.readJson.mockReturnValue(pkg);
      const pkgJson = yield scriptUtils.getProjectPkg();
      expect(pkgJson.name).toBe('@salesforce/pwa-kit-dev');
    }));
    test('should throw', /*#__PURE__*/_asyncToGenerator(function* () {
      _fsExtra.readJson.mockRejectedValue(Error);
      yield expect(scriptUtils.getProjectPkg()).rejects.toThrow(`Could not read project package at "${_path.default.join(process.cwd(), 'package.json')}"`);
    }));
  });
  describe('getLowestPackageVersion', () => {
    test('should work when major version is different', /*#__PURE__*/_asyncToGenerator(function* () {
      const lowestVersion = yield scriptUtils.getLowestPackageVersion('@salesforce/pwa-kit-react-sdk', dependencyTreeMockData.differentMajorVersions);
      expect(lowestVersion).toBe('9.0.0');
    }));
    test('should work when minor version is different', /*#__PURE__*/_asyncToGenerator(function* () {
      const lowestVersion = yield scriptUtils.getLowestPackageVersion('@salesforce/pwa-kit-react-sdk', dependencyTreeMockData.differentMinorVersions);
      expect(lowestVersion).toBe('1.9.0');
    }));
    test('should work when patch version is different', /*#__PURE__*/_asyncToGenerator(function* () {
      const lowestVersion = yield scriptUtils.getLowestPackageVersion('@salesforce/pwa-kit-react-sdk', dependencyTreeMockData.differentPatchVersions);
      expect(lowestVersion).toBe('1.0.9');
    }));
    test('should work when version contains pre-release version', /*#__PURE__*/_asyncToGenerator(function* () {
      const lowestVersion = yield scriptUtils.getLowestPackageVersion('@salesforce/pwa-kit-react-sdk', dependencyTreeMockData.preReleaseVersion);
      expect(lowestVersion).toBe('1.0.0-beta');
    }));
    test('should work when package is deduped', /*#__PURE__*/_asyncToGenerator(function* () {
      const lowestVersion = yield scriptUtils.getLowestPackageVersion('@salesforce/pwa-kit-react-sdk', dependencyTreeMockData.dedupedVersion);
      expect(lowestVersion).toBe('1.0.0');
    }));
    test("should return 'unknown' when package not found", /*#__PURE__*/_asyncToGenerator(function* () {
      const lowestVersion = yield scriptUtils.getLowestPackageVersion('@salesforce/pwa-kit-react-sdk', dependencyTreeMockData.noPwaKitPackages);
      expect(lowestVersion).toBe('unknown');
    }));
  });
  describe('getPwaKitDependencies', () => {
    test('should return pwa-kit packages with unknown version if not in dependency tree', /*#__PURE__*/_asyncToGenerator(function* () {
      const dependencies = yield scriptUtils.getPwaKitDependencies(dependencyTreeMockData.noPwaKitPackages);
      expect(Object.keys(dependencies)).toHaveLength(3);
      expect(dependencies).toHaveProperty('@salesforce/pwa-kit-react-sdk', 'unknown');
      expect(dependencies).toHaveProperty('@salesforce/pwa-kit-runtime', 'unknown');
      expect(dependencies).toHaveProperty('@salesforce/pwa-kit-dev', 'unknown');
    }));
    test('should return pwa-kit packages with version in dependency tree', /*#__PURE__*/_asyncToGenerator(function* () {
      const dependencies = yield scriptUtils.getPwaKitDependencies(dependencyTreeMockData.includesPwaKitPackages);
      expect(Object.keys(dependencies)).toHaveLength(3);
      expect(dependencies).toHaveProperty('@salesforce/pwa-kit-react-sdk', '1.0.0');
      expect(dependencies).toHaveProperty('@salesforce/pwa-kit-runtime', '1.0.0');
      expect(dependencies).toHaveProperty('@salesforce/pwa-kit-dev', '1.0.0');
    }));
  });
  describe('getProjectDependencyTree', () => {
    let originalCwd;
    beforeAll(() => {
      originalCwd = process.cwd();
    });
    afterEach(() => process.chdir(originalCwd));
    test('works in retail-react-app', /*#__PURE__*/_asyncToGenerator(function* () {
      expect(yield scriptUtils.getProjectDependencyTree()).toMatchObject({
        name: '@salesforce/pwa-kit-dev',
        version: pkg.version,
        dependencies: expect.any(Object)
      });
    }), 10_000); // This test can take a while on CI
    test('returns nothing if an error occurs', /*#__PURE__*/_asyncToGenerator(function* () {
      _child_process.execSync.mockImplementation(() => {
        throw new Error('npm ls did not work');
      });
      expect(yield scriptUtils.getProjectDependencyTree()).toBeNull();
    }));
  });
  describe('defaultMessage', () => {
    test('works', /*#__PURE__*/_asyncToGenerator(function* () {
      const mockGit = {
        branch: () => 'branch',
        short: () => 'short'
      };
      expect(scriptUtils.defaultMessage(mockGit)).toBe('branch: short');
    }));
    test('works outside of a git repo', /*#__PURE__*/_asyncToGenerator(function* () {
      const mockGit = {
        branch: () => {
          throw {
            code: 'ENOENT'
          };
        },
        short: () => 'short'
      };
      expect(scriptUtils.defaultMessage(mockGit)).toBe('PWA Kit Bundle');
    }));
    test('works with any other error', /*#__PURE__*/_asyncToGenerator(function* () {
      const mockGit = {
        branch: () => {
          throw new Error();
        },
        short: () => 'short'
      };
      expect(scriptUtils.defaultMessage(mockGit)).toBe('PWA Kit Bundle');
    }));
  });
  test('getCredentialsFile', /*#__PURE__*/_asyncToGenerator(function* () {
    expect(scriptUtils.getCredentialsFile('https://example.com', '/path/to/.mobify')).toBe('/path/to/.mobify');
    expect(scriptUtils.getCredentialsFile('https://example.com', undefined)).toBe(_path.default.join(_os.default.homedir(), '.mobify--example.com'));
    expect(scriptUtils.getCredentialsFile('https://cloud.mobify.com', undefined)).toBe(_path.default.join(_os.default.homedir(), '.mobify'));
  }));
  describe('readCredentials', () => {
    test('should work', /*#__PURE__*/_asyncToGenerator(function* () {
      _fsExtra.readJson.mockReturnValue({
        username: 'alice',
        api_key: 'xyz'
      });
      const creds = {
        username: 'alice',
        api_key: 'xyz'
      };
      const thePath = _path.default.join(tmpDir, '.mobify.test');
      yield (0, _fsExtra.writeFile)(thePath, JSON.stringify(creds), 'utf8');
      expect(yield scriptUtils.readCredentials(thePath)).toEqual(creds);
    }));
    test('should throw', /*#__PURE__*/_asyncToGenerator(function* () {
      const thePath = _path.default.join(tmpDir, '.mobify.test');
      yield expect( /*#__PURE__*/_asyncToGenerator(function* () {
        return yield scriptUtils.readCredentials(thePath);
      })).rejects.toThrow(Error);
    }));
  });
  describe('createBundle', () => {
    test('should throw if ssr_only and ssr_shared is empty', /*#__PURE__*/_asyncToGenerator(function* () {
      yield expect( /*#__PURE__*/_asyncToGenerator(function* () {
        return yield scriptUtils.createBundle({
          message: null,
          ssr_parameters: {},
          ssr_only: [],
          ssr_shared: [],
          buildDirectory: tmpDir,
          projectSlug: 'slug'
        });
      })).rejects.toThrow('no ssrOnly or ssrShared files are defined');
    }));
    test('should throw buildDir does not exist', /*#__PURE__*/_asyncToGenerator(function* () {
      yield expect( /*#__PURE__*/_asyncToGenerator(function* () {
        return yield scriptUtils.createBundle({
          message: null,
          ssr_parameters: {},
          ssr_only: ['*.js'],
          ssr_shared: ['*.js'],
          buildDirectory: _path.default.join(tmpDir, 'does-not-exist'),
          projectSlug: 'slug'
        });
      })).rejects.toThrow('Build directory at path');
    }));
    test('should archive a bundle', /*#__PURE__*/_asyncToGenerator(function* () {
      _fsExtra.readJson.mockReturnValue(pkg);
      _child_process.execSync.mockReturnValue(JSON.stringify(dependencyTreeMockData.noPwaKitPackages));
      const message = 'message';
      const bundle = yield scriptUtils.createBundle({
        message,
        ssr_parameters: {},
        ssr_only: ['*.js'],
        ssr_shared: ['**/*.*'],
        buildDirectory: _path.default.join(__dirname, 'test-fixtures', 'minimal-built-app'),
        projectSlug: 'slug'
      });
      expect(bundle.message).toEqual(message);
      expect(bundle.encoding).toBe('base64');
      expect(bundle.ssr_parameters).toEqual({});
      expect(bundle.ssr_only).toEqual(['ssr.js']);
      expect(bundle.ssr_shared).toEqual(['ssr.js', 'static/favicon.ico']);
      expect(bundle.bundle_metadata).toHaveProperty('dependencies');
      expect(bundle.bundle_metadata).toHaveProperty('cc_overrides');

      // De-code and re-encode gives the same result, to show that it *is* b64 encoded
      expect(Buffer.from(bundle.data, 'base64').toString('base64')).toEqual(bundle.data);
    }));
  });
  describe('pushBundle', () => {
    test.each([[{
      projectSlug: 'project-slug',
      targetSlug: undefined,
      expectedURL: 'https://cloud.mobify.com/api/projects/project-slug/builds/',
      status: 200
    }], [{
      projectSlug: 'project-slug',
      targetSlug: 'target-slug',
      expectedURL: 'https://cloud.mobify.com/api/projects/project-slug/builds/target-slug/',
      status: 200
    }], [{
      projectSlug: 'project-slug',
      targetSlug: undefined,
      expectedURL: 'https://cloud.mobify.com/api/projects/project-slug/builds/',
      status: 401
    }]])('should push a built bundle and handle status codes (%p)', /*#__PURE__*/function () {
      var _ref31 = _asyncToGenerator(function* ({
        projectSlug,
        targetSlug,
        expectedURL,
        status
      }) {
        _fsExtra.readJson.mockReturnValue(pkg);
        _child_process.execSync.mockReturnValue(JSON.stringify(dependencyTreeMockData.noPwaKitPackages));
        const message = 'message';
        const bundle = yield scriptUtils.createBundle({
          message,
          ssr_parameters: {},
          ssr_only: ['*.js'],
          ssr_shared: ['**/*.*'],
          buildDirectory: _path.default.join(__dirname, 'test-fixtures', 'minimal-built-app'),
          projectSlug
        });
        const username = 'user123';
        const api_key = '123';
        const credentials = {
          username,
          api_key
        };
        const goodResponseBody = {
          anything: 'anything'
        };

        // Older APIs on Cloud return JSON for good responses and text for errors,
        // hence the strange looking mock response setup.
        const text = () => status === 200 ? Promise.resolve(JSON.stringify(goodResponseBody)) : Promise.resolve('An error occurred');
        const json = () => status === 200 ? Promise.resolve(goodResponseBody) : Promise.reject();
        const responseMock = {
          status,
          text,
          json
        };
        const fetchMock = jest.fn( /*#__PURE__*/_asyncToGenerator(function* () {
          return responseMock;
        }));
        const client = new scriptUtils.CloudAPIClient({
          credentials,
          fetch: fetchMock
        });
        const fn = /*#__PURE__*/function () {
          var _ref33 = _asyncToGenerator(function* () {
            return yield client.push(bundle, projectSlug, targetSlug);
          });
          return function fn() {
            return _ref33.apply(this, arguments);
          };
        }();

        // TODO: Split up this batch of tests to avoid conditional assertions
        if (status === 200) {
          // eslint-disable-next-line jest/no-conditional-expect
          expect(yield fn()).toBe(goodResponseBody);
        } else {
          // eslint-disable-next-line jest/no-conditional-expect
          yield expect(fn).rejects.toThrow('For more information visit');
        }
        expect(fetchMock).toHaveBeenCalledTimes(1);
        expect(fetchMock).toHaveBeenCalledWith(expectedURL, expect.objectContaining({
          body: expect.anything(Buffer),
          method: 'POST',
          headers: {
            Authorization: expect.stringMatching(/^Basic /),
            'Content-Length': expect.stringMatching(/^\d+$/),
            'User-Agent': `${pkg.name}@${pkg.version}`
          }
        }));
      });
      return function (_x) {
        return _ref31.apply(this, arguments);
      };
    }());
  });
  describe('createLoggingToken', () => {
    const username = 'user123';
    const api_key = '123';
    test('createLoggingToken passes', /*#__PURE__*/_asyncToGenerator(function* () {
      _fsExtra.readJson.mockReturnValue(pkg);
      const projectSlug = 'project-slug';
      const targetSlug = 'target-slug';
      const text = () => Promise.resolve(JSON.stringify({
        token: 'token-value'
      }));
      const json = () => Promise.resolve({
        token: 'token-value'
      });
      const fetchMock = jest.fn( /*#__PURE__*/_asyncToGenerator(function* () {
        return {
          status: 200,
          text,
          json
        };
      }));
      const client = new scriptUtils.CloudAPIClient({
        credentials: {
          username,
          api_key
        },
        fetch: fetchMock
      });
      const fn = /*#__PURE__*/function () {
        var _ref36 = _asyncToGenerator(function* () {
          return yield client.createLoggingToken(projectSlug, targetSlug);
        });
        return function fn() {
          return _ref36.apply(this, arguments);
        };
      }();
      expect(yield fn()).toBe('token-value');
      expect(fetchMock).toHaveBeenCalledTimes(1);
      expect(fetchMock).toHaveBeenCalledWith('https://cloud.mobify.com/api/projects/project-slug/target/target-slug/jwt/', expect.objectContaining({
        method: 'POST',
        headers: {
          Authorization: expect.stringMatching(/^Bearer /),
          'User-Agent': `${pkg.name}@${pkg.version}`
        }
      }));
    }));
  });
  describe('parseLog', () => {
    it('correctly parses an application log', () => {
      const log = '2023-07-15T10:00:00Z\t550e8400-e29b-41d4-a716-446655440000\tINFO\tThis is a test log message';
      const result = scriptUtils.parseLog(log);
      expect(result).toEqual({
        level: 'INFO',
        message: 'This is a test log message',
        shortRequestId: '550e8400'
      });
    });
    it('correctly parses a platform log', () => {
      const log = 'WARN\tThis is a test log message';
      const result = scriptUtils.parseLog(log);
      expect(result).toEqual({
        level: 'WARN',
        message: '\tThis is a test log message',
        shortRequestId: undefined
      });
    });
    it('finds the shortRequestId in the message if not present in the request id', () => {
      const log = 'INFO\tThis is a test log message 550e8400';
      const result = scriptUtils.parseLog(log);
      expect(result).toEqual({
        level: 'INFO',
        message: '\tThis is a test log message 550e8400',
        shortRequestId: '550e8400'
      });
    });
  });
  describe('walkDir', () => {
    const files = ['a', 'b/1', 'b/2', 'c/d/e'].map(_path.default.normalize);
    beforeEach( /*#__PURE__*/_asyncToGenerator(function* () {
      yield Promise.all(files.map( /*#__PURE__*/function () {
        var _ref38 = _asyncToGenerator(function* (file) {
          return yield (0, _fsExtra.createFile)(_path.default.join(tmpDir, file));
        });
        return function (_x2) {
          return _ref38.apply(this, arguments);
        };
      }()));
    }));
    test('finds all files in a directory', /*#__PURE__*/_asyncToGenerator(function* () {
      const result = yield scriptUtils.walkDir(tmpDir, tmpDir);
      expect([...result]).toEqual(files);
    }));
    test('returns file relative to specified path', /*#__PURE__*/_asyncToGenerator(function* () {
      const result = yield scriptUtils.walkDir(tmpDir, '/');
      expect([...result]).toEqual(files.map(f => _path.default.join(tmpDir, f)));
    }));
  });
});