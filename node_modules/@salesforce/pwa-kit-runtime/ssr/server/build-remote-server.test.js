"use strict";

var _buildRemoteServer = require("./build-remote-server");
var _constants = require("./constants");
var _awsServerlessExpress = _interopRequireDefault(require("aws-serverless-express"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
jest.mock('aws-serverless-express', () => {
  return {
    createServer: jest.fn(),
    proxy: jest.fn()
  };
});
describe('the once function', () => {
  test('should prevent a function being called more than once', () => {
    const fn = jest.fn(() => ({
      test: 'test'
    }));
    const wrapped = (0, _buildRemoteServer.once)(fn);
    expect(fn.mock.calls).toHaveLength(0);
    const v1 = wrapped();
    expect(fn.mock.calls).toHaveLength(1);
    const v2 = wrapped();
    expect(fn.mock.calls).toHaveLength(1);
    expect(v1).toBe(v2); // The exact same instance
  });
});
describe('remote server factory test coverage', () => {
  test('getSlasEndpoint returns undefined if useSLASPrivateClient is false', () => {
    const endpoint = _buildRemoteServer.RemoteServerFactory._getSlasEndpoint({});
    expect(endpoint).toBeUndefined();
  });
  test('getSlasEndpoint returns endpoint if useSLASPrivateClient is true', () => {
    const endpoint = _buildRemoteServer.RemoteServerFactory._getSlasEndpoint({
      useSLASPrivateClient: true
    });
    expect(endpoint).toBeDefined();
  });
});
describe('encodeNonAsciiHttpHeaders flag in options to createHandler', () => {
  test('encodes request headers', () => {
    const mockApp = {
      sendMetric: jest.fn()
    };
    const mockOptions = {
      encodeNonAsciiHttpHeaders: true
    };
    const originalHeaders = {
      'x-non-ascii-header-one': 'テスト',
      'x-non-ascii-header-two': '测试',
      'x-regular-header': 'ascii-str'
    };
    const event = {
      headers: _objectSpread({}, originalHeaders)
    };
    const expectedHeaders = {
      'x-non-ascii-header-one': '%E3%83%86%E3%82%B9%E3%83%88',
      'x-non-ascii-header-two': '%E6%B5%8B%E8%AF%95',
      'x-encoded-headers': 'x-non-ascii-header-one,x-non-ascii-header-two',
      'x-regular-header': 'ascii-str'
    };
    const {
      handler
    } = _buildRemoteServer.RemoteServerFactory._createHandler(mockApp, mockOptions);
    expect(event.headers).toEqual(originalHeaders);
    handler(event, {}, {});
    expect(event.headers).toEqual(expectedHeaders);
    expect(decodeURIComponent(event.headers['x-non-ascii-header-one'])).toEqual(originalHeaders['x-non-ascii-header-one']);
  });
  test('encodes response headers', () => {
    const mockApp = {
      use: jest.fn()
    };
    const mockOptions = {
      encodeNonAsciiHttpHeaders: true
    };
    const res = {
      headers: {},
      setHeader: (key, value) => {
        res.headers[key] = value;
      },
      getHeader: key => {
        return res.headers[key];
      }
    };
    const nonASCIIheader = 'x-non-ascii-header';
    const nonASCIIstr = 'テスト';
    const expectedEncoding = '%E3%83%86%E3%82%B9%E3%83%88';
    const regularHeaderKey = 'x-regular-header';
    const regularHeaderValue = 'ascii-str';
    _buildRemoteServer.RemoteServerFactory._setupCommonMiddleware(mockApp, mockOptions);
    const encodeNonAsciiMiddleware = mockApp.use.mock.calls[3][0];
    res.setHeader(nonASCIIheader, nonASCIIstr);
    expect(res.getHeader(nonASCIIheader)).toEqual(nonASCIIstr);
    encodeNonAsciiMiddleware({}, res, () => {});
    res.setHeader(nonASCIIheader, nonASCIIstr);
    expect(res.getHeader(nonASCIIheader)).toEqual(expectedEncoding);
    expect(decodeURI(expectedEncoding)).toEqual(nonASCIIstr);
    expect(res.getHeader(_constants.X_ENCODED_HEADERS)).toEqual(nonASCIIheader);

    // confirm ASCII headers are not modified
    res.setHeader(regularHeaderKey, regularHeaderValue);
    expect(res.getHeader(regularHeaderKey)).toEqual(regularHeaderValue);
  });
});