"use strict";

var utils = _interopRequireWildcard(require("./utils"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); } /*
 * Copyright (c) 2022, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
describe.each([[true], [false]])('Utils remote/local tests (isRemote: %p)', isRemote => {
  let originalEnv;
  const bundleId = 'test-bundle-id-12345';
  beforeEach(() => {
    originalEnv = process.env;
    process.env = _extends({}, process.env);
    process.env.BUNDLE_ID = bundleId;
    if (isRemote) {
      process.env.AWS_LAMBDA_FUNCTION_NAME = 'remote-test-name';
    }
  });
  afterEach(() => {
    process.env = originalEnv;
    jest.restoreAllMocks();
  });
  test(`getBundleBaseUrl should return the correct URL`, () => {
    const expectedId = isRemote ? bundleId : 'development';
    const expected = `/mobify/bundle/${expectedId}/`;
    expect(utils.getBundleBaseUrl()).toBe(expected);
  });
  describe.each([[true], [false]])('Quiet/loud tests', quiet => {
    let originalQuiet;
    beforeEach(() => {
      originalQuiet = utils.isQuiet();
      utils.setQuiet(quiet);
    });
    afterEach(() => {
      utils.setQuiet(originalQuiet);
      jest.restoreAllMocks();
    });
    test(`localDevLog should log conditionally (quiet: ${quiet})`, () => {
      const log = jest.spyOn(console, 'log').mockImplementation(() => {});
      const msg = 'message';
      utils.localDevLog(msg);
      const expected = !isRemote && !quiet ? [[msg]] : [];
      expect(log.mock.calls).toEqual(expected);
    });
    test(`infoLog should log conditionally (quiet: ${quiet})`, () => {
      const log = jest.spyOn(console, 'log').mockImplementation(() => {});
      const msg = 'message';
      utils.infoLog(msg);
      const expected = !quiet ? [[msg]] : [];
      expect(log.mock.calls).toEqual(expected);
    });
  });
});
describe('catchAndLog', () => {
  test('error', () => {
    const error = jest.spyOn(console, 'error').mockImplementation(() => {});
    utils.catchAndLog();
    expect(error).toHaveBeenCalledWith('pwa-kit-runtime.catchAndLog ERROR Uncaught exception:  {"stack":"(no error)"}');
  });
});