"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.verboseProxyLogging = exports.setQuiet = exports.parseCacheControl = exports.localDevLog = exports.isRemote = exports.isQuiet = exports.infoLog = exports.getHashForString = exports.getFullRequestURL = exports.getBundleBaseUrl = exports.escapeJSText = exports.catchAndLog = void 0;
var _crypto = _interopRequireDefault(require("crypto"));
var _ssrShared = require("../ssr-shared");
var _ssrNamespacePaths = require("../ssr-namespace-paths");
var _loggerInstance = _interopRequireDefault(require("../logger-instance"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/*
 * Copyright (c) 2022, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */

// To avoid an unwieldy file size, this file should be for utils that are less than ~20 lines.
// Larger utils should be placed in separate files.
// Also, ./utils/ssr-server/utils is a bit of a silly name, but these helpers can't live in
// ../ssr-server.js because it would create circular dependencies.

// TODO: Clean this up or provide a way to toggle
const verboseProxyLogging = exports.verboseProxyLogging = false;
const isRemote = () => Object.prototype.hasOwnProperty.call(process.env, 'AWS_LAMBDA_FUNCTION_NAME');
exports.isRemote = isRemote;
const getBundleBaseUrl = () => {
  return `${_ssrNamespacePaths.bundleBasePath}/${isRemote() ? process.env.BUNDLE_ID : 'development'}/`;
};
exports.getBundleBaseUrl = getBundleBaseUrl;
let QUIET = false;
const setQuiet = quiet => {
  QUIET = quiet;
};
exports.setQuiet = setQuiet;
const isQuiet = () => QUIET;

// Logs in local development server mode only
exports.isQuiet = isQuiet;
const localDevLog = (...args) => {
  if (!isRemote() && !QUIET) {
    /* istanbul ignore next */
    console.log(...args);
  }
};

// Logs unless server is in quiet mode (used for tests)
exports.localDevLog = localDevLog;
const infoLog = (...args) => {
  /* istanbul ignore next */
  if (!QUIET) {
    /* istanbul ignore next */
    console.log(...args);
  }
};

/**
 * A global error catcher
 * @private
 */
exports.infoLog = infoLog;
const catchAndLog = (err, context) => {
  /* istanbul ignore next */
  const message = `${context || 'Uncaught exception'}: `;
  _loggerInstance.default.error(message, /* istanbul ignore next */
  {
    namespace: 'catchAndLog',
    additionalProperties: {
      stack: err && (err.stack || err.message || err) || '(no error)'
    }
  });
};

/**
 * Given a piece of JavaScript or JSON as text, escape any
 * '</' so that it can be embedded within HTML.
 *
 * @private
 * @param {String} text
 * @returns {String}
 */
exports.catchAndLog = catchAndLog;
const escapeJSText = text => text === null || text === void 0 ? void 0 : text.replace(/<\//gm, '\\x3c\\x2f');
exports.escapeJSText = escapeJSText;
const getHashForString = text => {
  const hash = _crypto.default.createHash('sha256');
  hash.update(text);
  return hash.digest('hex');
};
exports.getHashForString = getHashForString;
const getFullRequestURL = url => {
  // If it starts with a protocol (e.g. http(s)://, file://), then it's already a full URL
  if (/^[a-zA-Z]+:\/\//.test(url)) return url;
  const proxy = _ssrShared.proxyConfigs.find(({
    path
  }) => url.startsWith(`${_ssrNamespacePaths.proxyBasePath}/${path}/`));
  if (proxy) {
    return url.replace(`${_ssrNamespacePaths.proxyBasePath}/${proxy.path}`, `${proxy.protocol}://${proxy.host}`);
  }
  throw new Error(`Unable to fetch ${url}, relative paths must begin with ${_ssrNamespacePaths.proxyBasePath} followed by a configured proxy path.`);
};
exports.getFullRequestURL = getFullRequestURL;
const CC_AGE_RE = /(s-maxage|max-age)\s*=\s*(\d+)/gi;

/**
 * Perform limited parsing of a Cache-Control header value, to
 * extract the s-maxage and max-age values and return them.
 *
 * @function
 * @param value {String} the value to parse
 * @returns {Object} with 'max-age' and 's-maxage' properties mapped
 * to String or undefined values.
 */
const parseCacheControl = value => {
  const result = {};
  if (value) {
    for (const match of value.matchAll(CC_AGE_RE)) {
      result[match[1].toLowerCase()] = match[2];
    }
  }
  return result;
};
exports.parseCacheControl = parseCacheControl;