"use strict";

var _ssrCache = require("./ssr-cache");
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; } /*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const localRemoteTestCases = [true, false];
localRemoteTestCases.forEach(useLocalCache => {
  describe(`${useLocalCache ? 'Local' : 'Remote'} noop PersistentCache`, () => {
    const testCache = new _ssrCache.PersistentCache({
      useLocalCache,
      bucket: 'TestBucket',
      s3Endpoint: 'http://localhost:4568',
      accessKeyId: 'S3RVER',
      secretAccessKey: 'S3RVER',
      sendMetric: () => {}
    });
    const key = 'key';
    const namespace = 'namespace';
    const buf = Buffer.alloc(8);
    for (let i = 0; i <= 8; i++) {
      buf[i] = i;
    }
    const expiration = Date.now() + 10000;
    test('get', /*#__PURE__*/_asyncToGenerator(function* () {
      const result = yield testCache.get({
        key,
        namespace
      });
      expect(result.data).toBeUndefined();
      expect(result.metadata).toBeUndefined();
      expect(result.found).toBe(false);
      expect(result.key).toEqual(key);
      expect(result.namespace).toEqual(namespace);
    }));
    test('put', /*#__PURE__*/_asyncToGenerator(function* () {
      yield testCache.put({
        key,
        namespace,
        data: buf,
        expiration
      });
      const result = yield testCache.get({
        key,
        namespace
      });
      expect(result.data).toBeUndefined();
      expect(result.metadata).toBeUndefined();
      expect(result.found).toBe(false);
      expect(result.key).toEqual(key);
      expect(result.namespace).toEqual(namespace);
    }));
    test('delete', /*#__PURE__*/_asyncToGenerator(function* () {
      yield expect(testCache.delete({
        key,
        namespace
      })).resolves.not.toThrow();
    }));
  });
});